// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: motion.proto

#ifndef PROTOBUF_motion_2eproto__INCLUDED
#define PROTOBUF_motion_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace motion {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_motion_2eproto();
void protobuf_AssignDesc_motion_2eproto();
void protobuf_ShutdownFile_motion_2eproto();

class Message;
class Message_MotionDevice;
class Message_MotionUser;
class Message_MotionCamera;
class Message_MotionTrack;
class Message_MotionRec;
class Message_MotionCron;
class Message_MotionMonth;
class Message_MotionDay;
class Message_Instance;
class Message_Image;
class Message_Crop;
class Message_Video;

enum Message_ResponseType {
  Message_ResponseType_LOGIN_SUCCESSFUL = 100,
  Message_ResponseType_LOGIN_FAILED = 101,
  Message_ResponseType_ERROR_INVALID_USERNAME = 102,
  Message_ResponseType_ERROR_INVALID_PASSWORD = 103,
  Message_ResponseType_ERROR_LOGIN_FAILIURE = 104,
  Message_ResponseType_ERROR_TIMEOUT = 105
};
bool Message_ResponseType_IsValid(int value);
const Message_ResponseType Message_ResponseType_ResponseType_MIN = Message_ResponseType_LOGIN_SUCCESSFUL;
const Message_ResponseType Message_ResponseType_ResponseType_MAX = Message_ResponseType_ERROR_TIMEOUT;
const int Message_ResponseType_ResponseType_ARRAYSIZE = Message_ResponseType_ResponseType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Message_ResponseType_descriptor();
inline const ::std::string& Message_ResponseType_Name(Message_ResponseType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Message_ResponseType_descriptor(), value);
}
inline bool Message_ResponseType_Parse(
    const ::std::string& name, Message_ResponseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Message_ResponseType>(
    Message_ResponseType_descriptor(), name, value);
}
enum Message_ActionType {
  Message_ActionType_ENGAGE = 1000,
  Message_ActionType_REC_START = 1002,
  Message_ActionType_REC_RUNNING = 1003,
  Message_ActionType_REC_STOP = 1004,
  Message_ActionType_UNENGAGE = 1005,
  Message_ActionType_GET_TIME = 1006,
  Message_ActionType_SET_TIME = 1007,
  Message_ActionType_TIME_SET = 1008,
  Message_ActionType_STRM_START = 1009,
  Message_ActionType_STRM_STOP = 1010,
  Message_ActionType_TAKE_PICTURE = 1011,
  Message_ActionType_DISSCONNECT = 1012,
  Message_ActionType_REFRESH = 1013,
  Message_ActionType_GET_XML = 1014,
  Message_ActionType_GET_IMAGE = 1015,
  Message_ActionType_GET_VIDEO = 1016,
  Message_ActionType_SAVE = 1017,
  Message_ActionType_OPEN = 1018,
  Message_ActionType_UPDATE = 1019,
  Message_ActionType_SAVE_OK = 1020,
  Message_ActionType_UPDATE_OK = 1021,
  Message_ActionType_GET_MAT = 1022,
  Message_ActionType_RESPONSE_OK = 2000,
  Message_ActionType_RESPONSE_NEXT = 2010,
  Message_ActionType_RESPONSE_END = 2020,
  Message_ActionType_RESPONSE_FINISH = 2030,
  Message_ActionType_REC_HAS_CHANGES = 2040,
  Message_ActionType_REC_HAS_INSTANCE = 2050,
  Message_ActionType_PROTO_HAS_FILE = 3030,
  Message_ActionType_PROTO_NO_FILE = 3031,
  Message_ActionType_SERVER_INFO = 3032,
  Message_ActionType_SERVER_INFO_OK = 3033
};
bool Message_ActionType_IsValid(int value);
const Message_ActionType Message_ActionType_ActionType_MIN = Message_ActionType_ENGAGE;
const Message_ActionType Message_ActionType_ActionType_MAX = Message_ActionType_SERVER_INFO_OK;
const int Message_ActionType_ActionType_ARRAYSIZE = Message_ActionType_ActionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Message_ActionType_descriptor();
inline const ::std::string& Message_ActionType_Name(Message_ActionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Message_ActionType_descriptor(), value);
}
inline bool Message_ActionType_Parse(
    const ::std::string& name, Message_ActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Message_ActionType>(
    Message_ActionType_descriptor(), name, value);
}
enum Message_SocketType {
  Message_SocketType_SOCKET_PROTO_TOSTRING = 10,
  Message_SocketType_SOCKET_PROTO_TOARRAY = 11,
  Message_SocketType_SOCKET_PLAIN_TEXT = 12,
  Message_SocketType_SPLITTED_MESSAGE = 13,
  Message_SocketType_SINGLE_MESSAGE = 14,
  Message_SocketType_SOCKET_BUFFER_NANO_SIZE = 1024,
  Message_SocketType_SOCKET_BUFFER_MINI_SIZE = 2048,
  Message_SocketType_SOCKET_BUFFER_MICRO_SIZE = 4096,
  Message_SocketType_SOCKET_BUFFER_SMALL_SIZE = 8196,
  Message_SocketType_SOCKET_BUFFER_REGULAR_SIZE = 16392,
  Message_SocketType_SOCKET_BUFFER_MEDIUM_SIZE = 32784,
  Message_SocketType_SOCKET_BUFFER_BIG_SIZE = 65568,
  Message_SocketType_TCP_ECHO_PORT = 5010,
  Message_SocketType_TCP_STREAMING_PORT = 5020,
  Message_SocketType_UDP_PORT = 5030,
  Message_SocketType_TCP_MSG_PORT = 5040
};
bool Message_SocketType_IsValid(int value);
const Message_SocketType Message_SocketType_SocketType_MIN = Message_SocketType_SOCKET_PROTO_TOSTRING;
const Message_SocketType Message_SocketType_SocketType_MAX = Message_SocketType_SOCKET_BUFFER_BIG_SIZE;
const int Message_SocketType_SocketType_ARRAYSIZE = Message_SocketType_SocketType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Message_SocketType_descriptor();
inline const ::std::string& Message_SocketType_Name(Message_SocketType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Message_SocketType_descriptor(), value);
}
inline bool Message_SocketType_Parse(
    const ::std::string& name, Message_SocketType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Message_SocketType>(
    Message_SocketType_descriptor(), name, value);
}
enum Message_ProcessType {
  Message_ProcessType_PROCESS_PEOPLE_COUNT = 4001,
  Message_ProcessType_PROCESS_FACE_DETECT = 4002,
  Message_ProcessType_PROCESS_WALK_DIRECTION = 4003
};
bool Message_ProcessType_IsValid(int value);
const Message_ProcessType Message_ProcessType_ProcessType_MIN = Message_ProcessType_PROCESS_PEOPLE_COUNT;
const Message_ProcessType Message_ProcessType_ProcessType_MAX = Message_ProcessType_PROCESS_WALK_DIRECTION;
const int Message_ProcessType_ProcessType_ARRAYSIZE = Message_ProcessType_ProcessType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Message_ProcessType_descriptor();
inline const ::std::string& Message_ProcessType_Name(Message_ProcessType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Message_ProcessType_descriptor(), value);
}
inline bool Message_ProcessType_Parse(
    const ::std::string& name, Message_ProcessType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Message_ProcessType>(
    Message_ProcessType_descriptor(), name, value);
}
enum Message_ServiceType {
  Message_ServiceType_SERVICE_FREE_ACCOUNT = 5001,
  Message_ServiceType_SERVICE_PAID_ACCOUNT = 5002
};
bool Message_ServiceType_IsValid(int value);
const Message_ServiceType Message_ServiceType_ServiceType_MIN = Message_ServiceType_SERVICE_FREE_ACCOUNT;
const Message_ServiceType Message_ServiceType_ServiceType_MAX = Message_ServiceType_SERVICE_PAID_ACCOUNT;
const int Message_ServiceType_ServiceType_ARRAYSIZE = Message_ServiceType_ServiceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Message_ServiceType_descriptor();
inline const ::std::string& Message_ServiceType_Name(Message_ServiceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Message_ServiceType_descriptor(), value);
}
inline bool Message_ServiceType_Parse(
    const ::std::string& name, Message_ServiceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Message_ServiceType>(
    Message_ServiceType_descriptor(), name, value);
}
// ===================================================================

class Message_MotionDevice : public ::google::protobuf::Message {
 public:
  Message_MotionDevice();
  virtual ~Message_MotionDevice();

  Message_MotionDevice(const Message_MotionDevice& from);

  inline Message_MotionDevice& operator=(const Message_MotionDevice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_MotionDevice& default_instance();

  void Swap(Message_MotionDevice* other);

  // implements Message ----------------------------------------------

  Message_MotionDevice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_MotionDevice& from);
  void MergeFrom(const Message_MotionDevice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ipnumber = 1;
  inline bool has_ipnumber() const;
  inline void clear_ipnumber();
  static const int kIpnumberFieldNumber = 1;
  inline const ::std::string& ipnumber() const;
  inline void set_ipnumber(const ::std::string& value);
  inline void set_ipnumber(const char* value);
  inline void set_ipnumber(const char* value, size_t size);
  inline ::std::string* mutable_ipnumber();
  inline ::std::string* release_ipnumber();
  inline void set_allocated_ipnumber(::std::string* ipnumber);

  // optional string ippublic = 2;
  inline bool has_ippublic() const;
  inline void clear_ippublic();
  static const int kIppublicFieldNumber = 2;
  inline const ::std::string& ippublic() const;
  inline void set_ippublic(const ::std::string& value);
  inline void set_ippublic(const char* value);
  inline void set_ippublic(const char* value, size_t size);
  inline ::std::string* mutable_ippublic();
  inline ::std::string* release_ippublic();
  inline void set_allocated_ippublic(::std::string* ippublic);

  // optional string macaddress = 3;
  inline bool has_macaddress() const;
  inline void clear_macaddress();
  static const int kMacaddressFieldNumber = 3;
  inline const ::std::string& macaddress() const;
  inline void set_macaddress(const ::std::string& value);
  inline void set_macaddress(const char* value);
  inline void set_macaddress(const char* value, size_t size);
  inline ::std::string* mutable_macaddress();
  inline ::std::string* release_macaddress();
  inline void set_allocated_macaddress(::std::string* macaddress);

  // optional string hostname = 4;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 4;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional string city = 5;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 5;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const char* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  inline void set_allocated_city(::std::string* city);

  // optional string country = 6;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 6;
  inline const ::std::string& country() const;
  inline void set_country(const ::std::string& value);
  inline void set_country(const char* value);
  inline void set_country(const char* value, size_t size);
  inline ::std::string* mutable_country();
  inline ::std::string* release_country();
  inline void set_allocated_country(::std::string* country);

  // optional string location = 7;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 7;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  inline void set_allocated_location(::std::string* location);

  // optional string network_provider = 8;
  inline bool has_network_provider() const;
  inline void clear_network_provider();
  static const int kNetworkProviderFieldNumber = 8;
  inline const ::std::string& network_provider() const;
  inline void set_network_provider(const ::std::string& value);
  inline void set_network_provider(const char* value);
  inline void set_network_provider(const char* value, size_t size);
  inline ::std::string* mutable_network_provider();
  inline ::std::string* release_network_provider();
  inline void set_allocated_network_provider(::std::string* network_provider);

  // optional string uptime = 9;
  inline bool has_uptime() const;
  inline void clear_uptime();
  static const int kUptimeFieldNumber = 9;
  inline const ::std::string& uptime() const;
  inline void set_uptime(const ::std::string& value);
  inline void set_uptime(const char* value);
  inline void set_uptime(const char* value, size_t size);
  inline ::std::string* mutable_uptime();
  inline ::std::string* release_uptime();
  inline void set_allocated_uptime(::std::string* uptime);

  // optional string starttime = 10;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 10;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  inline void set_allocated_starttime(::std::string* starttime);

  // optional int32 db_local = 11;
  inline bool has_db_local() const;
  inline void clear_db_local();
  static const int kDbLocalFieldNumber = 11;
  inline ::google::protobuf::int32 db_local() const;
  inline void set_db_local(::google::protobuf::int32 value);

  // optional string model = 12;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 12;
  inline const ::std::string& model() const;
  inline void set_model(const ::std::string& value);
  inline void set_model(const char* value);
  inline void set_model(const char* value, size_t size);
  inline ::std::string* mutable_model();
  inline ::std::string* release_model();
  inline void set_allocated_model(::std::string* model);

  // optional string hardware = 13;
  inline bool has_hardware() const;
  inline void clear_hardware();
  static const int kHardwareFieldNumber = 13;
  inline const ::std::string& hardware() const;
  inline void set_hardware(const ::std::string& value);
  inline void set_hardware(const char* value);
  inline void set_hardware(const char* value, size_t size);
  inline ::std::string* mutable_hardware();
  inline ::std::string* release_hardware();
  inline void set_allocated_hardware(::std::string* hardware);

  // optional string serial = 14;
  inline bool has_serial() const;
  inline void clear_serial();
  static const int kSerialFieldNumber = 14;
  inline const ::std::string& serial() const;
  inline void set_serial(const ::std::string& value);
  inline void set_serial(const char* value);
  inline void set_serial(const char* value, size_t size);
  inline ::std::string* mutable_serial();
  inline ::std::string* release_serial();
  inline void set_allocated_serial(::std::string* serial);

  // optional string revision = 15;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 15;
  inline const ::std::string& revision() const;
  inline void set_revision(const ::std::string& value);
  inline void set_revision(const char* value);
  inline void set_revision(const char* value, size_t size);
  inline ::std::string* mutable_revision();
  inline ::std::string* release_revision();
  inline void set_allocated_revision(::std::string* revision);

  // optional int32 disktotal = 16;
  inline bool has_disktotal() const;
  inline void clear_disktotal();
  static const int kDisktotalFieldNumber = 16;
  inline ::google::protobuf::int32 disktotal() const;
  inline void set_disktotal(::google::protobuf::int32 value);

  // optional int32 diskused = 17;
  inline bool has_diskused() const;
  inline void clear_diskused();
  static const int kDiskusedFieldNumber = 17;
  inline ::google::protobuf::int32 diskused() const;
  inline void set_diskused(::google::protobuf::int32 value);

  // optional int32 diskavailable = 18;
  inline bool has_diskavailable() const;
  inline void clear_diskavailable();
  static const int kDiskavailableFieldNumber = 18;
  inline ::google::protobuf::int32 diskavailable() const;
  inline void set_diskavailable(::google::protobuf::int32 value);

  // optional int32 disk_percentage_used = 19;
  inline bool has_disk_percentage_used() const;
  inline void clear_disk_percentage_used();
  static const int kDiskPercentageUsedFieldNumber = 19;
  inline ::google::protobuf::int32 disk_percentage_used() const;
  inline void set_disk_percentage_used(::google::protobuf::int32 value);

  // optional int32 temperature = 20;
  inline bool has_temperature() const;
  inline void clear_temperature();
  static const int kTemperatureFieldNumber = 20;
  inline ::google::protobuf::int32 temperature() const;
  inline void set_temperature(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:motion.Message.MotionDevice)
 private:
  inline void set_has_ipnumber();
  inline void clear_has_ipnumber();
  inline void set_has_ippublic();
  inline void clear_has_ippublic();
  inline void set_has_macaddress();
  inline void clear_has_macaddress();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_network_provider();
  inline void clear_has_network_provider();
  inline void set_has_uptime();
  inline void clear_has_uptime();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_db_local();
  inline void clear_has_db_local();
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_hardware();
  inline void clear_has_hardware();
  inline void set_has_serial();
  inline void clear_has_serial();
  inline void set_has_revision();
  inline void clear_has_revision();
  inline void set_has_disktotal();
  inline void clear_has_disktotal();
  inline void set_has_diskused();
  inline void clear_has_diskused();
  inline void set_has_diskavailable();
  inline void clear_has_diskavailable();
  inline void set_has_disk_percentage_used();
  inline void clear_has_disk_percentage_used();
  inline void set_has_temperature();
  inline void clear_has_temperature();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ipnumber_;
  ::std::string* ippublic_;
  ::std::string* macaddress_;
  ::std::string* hostname_;
  ::std::string* city_;
  ::std::string* country_;
  ::std::string* location_;
  ::std::string* network_provider_;
  ::std::string* uptime_;
  ::std::string* starttime_;
  ::std::string* model_;
  ::std::string* hardware_;
  ::google::protobuf::int32 db_local_;
  ::google::protobuf::int32 disktotal_;
  ::std::string* serial_;
  ::std::string* revision_;
  ::google::protobuf::int32 diskused_;
  ::google::protobuf::int32 diskavailable_;
  ::google::protobuf::int32 disk_percentage_used_;
  ::google::protobuf::int32 temperature_;
  friend void  protobuf_AddDesc_motion_2eproto();
  friend void protobuf_AssignDesc_motion_2eproto();
  friend void protobuf_ShutdownFile_motion_2eproto();

  void InitAsDefaultInstance();
  static Message_MotionDevice* default_instance_;
};
// -------------------------------------------------------------------

class Message_MotionUser : public ::google::protobuf::Message {
 public:
  Message_MotionUser();
  virtual ~Message_MotionUser();

  Message_MotionUser(const Message_MotionUser& from);

  inline Message_MotionUser& operator=(const Message_MotionUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_MotionUser& default_instance();

  void Swap(Message_MotionUser* other);

  // implements Message ----------------------------------------------

  Message_MotionUser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_MotionUser& from);
  void MergeFrom(const Message_MotionUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 clientnumber = 1;
  inline bool has_clientnumber() const;
  inline void clear_clientnumber();
  static const int kClientnumberFieldNumber = 1;
  inline ::google::protobuf::int32 clientnumber() const;
  inline void set_clientnumber(::google::protobuf::int32 value);

  // optional string wpuser = 2;
  inline bool has_wpuser() const;
  inline void clear_wpuser();
  static const int kWpuserFieldNumber = 2;
  inline const ::std::string& wpuser() const;
  inline void set_wpuser(const ::std::string& value);
  inline void set_wpuser(const char* value);
  inline void set_wpuser(const char* value, size_t size);
  inline ::std::string* mutable_wpuser();
  inline ::std::string* release_wpuser();
  inline void set_allocated_wpuser(::std::string* wpuser);

  // optional string wppassword = 3;
  inline bool has_wppassword() const;
  inline void clear_wppassword();
  static const int kWppasswordFieldNumber = 3;
  inline const ::std::string& wppassword() const;
  inline void set_wppassword(const ::std::string& value);
  inline void set_wppassword(const char* value);
  inline void set_wppassword(const char* value, size_t size);
  inline ::std::string* mutable_wppassword();
  inline ::std::string* release_wppassword();
  inline void set_allocated_wppassword(::std::string* wppassword);

  // optional string wpserverurl = 4;
  inline bool has_wpserverurl() const;
  inline void clear_wpserverurl();
  static const int kWpserverurlFieldNumber = 4;
  inline const ::std::string& wpserverurl() const;
  inline void set_wpserverurl(const ::std::string& value);
  inline void set_wpserverurl(const char* value);
  inline void set_wpserverurl(const char* value, size_t size);
  inline ::std::string* mutable_wpserverurl();
  inline ::std::string* release_wpserverurl();
  inline void set_allocated_wpserverurl(::std::string* wpserverurl);

  // optional int32 wpuserid = 5;
  inline bool has_wpuserid() const;
  inline void clear_wpuserid();
  static const int kWpuseridFieldNumber = 5;
  inline ::google::protobuf::int32 wpuserid() const;
  inline void set_wpuserid(::google::protobuf::int32 value);

  // optional int32 wpclientid = 6;
  inline bool has_wpclientid() const;
  inline void clear_wpclientid();
  static const int kWpclientidFieldNumber = 6;
  inline ::google::protobuf::int32 wpclientid() const;
  inline void set_wpclientid(::google::protobuf::int32 value);

  // optional int32 wpclientmediaid = 7;
  inline bool has_wpclientmediaid() const;
  inline void clear_wpclientmediaid();
  static const int kWpclientmediaidFieldNumber = 7;
  inline ::google::protobuf::int32 wpclientmediaid() const;
  inline void set_wpclientmediaid(::google::protobuf::int32 value);

  // optional string pfobjectid = 8;
  inline bool has_pfobjectid() const;
  inline void clear_pfobjectid();
  static const int kPfobjectidFieldNumber = 8;
  inline const ::std::string& pfobjectid() const;
  inline void set_pfobjectid(const ::std::string& value);
  inline void set_pfobjectid(const char* value);
  inline void set_pfobjectid(const char* value, size_t size);
  inline ::std::string* mutable_pfobjectid();
  inline ::std::string* release_pfobjectid();
  inline void set_allocated_pfobjectid(::std::string* pfobjectid);

  // optional string username = 9;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 9;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string email = 10;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 10;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional string firstname = 11;
  inline bool has_firstname() const;
  inline void clear_firstname();
  static const int kFirstnameFieldNumber = 11;
  inline const ::std::string& firstname() const;
  inline void set_firstname(const ::std::string& value);
  inline void set_firstname(const char* value);
  inline void set_firstname(const char* value, size_t size);
  inline ::std::string* mutable_firstname();
  inline ::std::string* release_firstname();
  inline void set_allocated_firstname(::std::string* firstname);

  // optional string lastname = 12;
  inline bool has_lastname() const;
  inline void clear_lastname();
  static const int kLastnameFieldNumber = 12;
  inline const ::std::string& lastname() const;
  inline void set_lastname(const ::std::string& value);
  inline void set_lastname(const char* value);
  inline void set_lastname(const char* value, size_t size);
  inline ::std::string* mutable_lastname();
  inline ::std::string* release_lastname();
  inline void set_allocated_lastname(::std::string* lastname);

  // optional string location = 13;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 13;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  inline void set_allocated_location(::std::string* location);

  // optional string uiidinstallation = 14;
  inline bool has_uiidinstallation() const;
  inline void clear_uiidinstallation();
  static const int kUiidinstallationFieldNumber = 14;
  inline const ::std::string& uiidinstallation() const;
  inline void set_uiidinstallation(const ::std::string& value);
  inline void set_uiidinstallation(const char* value);
  inline void set_uiidinstallation(const char* value, size_t size);
  inline ::std::string* mutable_uiidinstallation();
  inline ::std::string* release_uiidinstallation();
  inline void set_allocated_uiidinstallation(::std::string* uiidinstallation);

  // optional int32 service_type = 15;
  inline bool has_service_type() const;
  inline void clear_service_type();
  static const int kServiceTypeFieldNumber = 15;
  inline ::google::protobuf::int32 service_type() const;
  inline void set_service_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:motion.Message.MotionUser)
 private:
  inline void set_has_clientnumber();
  inline void clear_has_clientnumber();
  inline void set_has_wpuser();
  inline void clear_has_wpuser();
  inline void set_has_wppassword();
  inline void clear_has_wppassword();
  inline void set_has_wpserverurl();
  inline void clear_has_wpserverurl();
  inline void set_has_wpuserid();
  inline void clear_has_wpuserid();
  inline void set_has_wpclientid();
  inline void clear_has_wpclientid();
  inline void set_has_wpclientmediaid();
  inline void clear_has_wpclientmediaid();
  inline void set_has_pfobjectid();
  inline void clear_has_pfobjectid();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_firstname();
  inline void clear_has_firstname();
  inline void set_has_lastname();
  inline void clear_has_lastname();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_uiidinstallation();
  inline void clear_has_uiidinstallation();
  inline void set_has_service_type();
  inline void clear_has_service_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* wpuser_;
  ::std::string* wppassword_;
  ::google::protobuf::int32 clientnumber_;
  ::google::protobuf::int32 wpuserid_;
  ::std::string* wpserverurl_;
  ::google::protobuf::int32 wpclientid_;
  ::google::protobuf::int32 wpclientmediaid_;
  ::std::string* pfobjectid_;
  ::std::string* username_;
  ::std::string* email_;
  ::std::string* firstname_;
  ::std::string* lastname_;
  ::std::string* location_;
  ::std::string* uiidinstallation_;
  ::google::protobuf::int32 service_type_;
  friend void  protobuf_AddDesc_motion_2eproto();
  friend void protobuf_AssignDesc_motion_2eproto();
  friend void protobuf_ShutdownFile_motion_2eproto();

  void InitAsDefaultInstance();
  static Message_MotionUser* default_instance_;
};
// -------------------------------------------------------------------

class Message_MotionCamera : public ::google::protobuf::Message {
 public:
  Message_MotionCamera();
  virtual ~Message_MotionCamera();

  Message_MotionCamera(const Message_MotionCamera& from);

  inline Message_MotionCamera& operator=(const Message_MotionCamera& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_MotionCamera& default_instance();

  void Swap(Message_MotionCamera* other);

  // implements Message ----------------------------------------------

  Message_MotionCamera* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_MotionCamera& from);
  void MergeFrom(const Message_MotionCamera& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .motion.Message.MotionMonth motionmonth = 1;
  inline int motionmonth_size() const;
  inline void clear_motionmonth();
  static const int kMotionmonthFieldNumber = 1;
  inline const ::motion::Message_MotionMonth& motionmonth(int index) const;
  inline ::motion::Message_MotionMonth* mutable_motionmonth(int index);
  inline ::motion::Message_MotionMonth* add_motionmonth();
  inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionMonth >&
      motionmonth() const;
  inline ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionMonth >*
      mutable_motionmonth();

  // repeated .motion.Message.MotionRec motionrec = 2;
  inline int motionrec_size() const;
  inline void clear_motionrec();
  static const int kMotionrecFieldNumber = 2;
  inline const ::motion::Message_MotionRec& motionrec(int index) const;
  inline ::motion::Message_MotionRec* mutable_motionrec(int index);
  inline ::motion::Message_MotionRec* add_motionrec();
  inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionRec >&
      motionrec() const;
  inline ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionRec >*
      mutable_motionrec();

  // optional int32 cameraid = 3 [default = 0];
  inline bool has_cameraid() const;
  inline void clear_cameraid();
  static const int kCameraidFieldNumber = 3;
  inline ::google::protobuf::int32 cameraid() const;
  inline void set_cameraid(::google::protobuf::int32 value);

  // optional int32 cameranumber = 4;
  inline bool has_cameranumber() const;
  inline void clear_cameranumber();
  static const int kCameranumberFieldNumber = 4;
  inline ::google::protobuf::int32 cameranumber() const;
  inline void set_cameranumber(::google::protobuf::int32 value);

  // optional string cameraname = 5;
  inline bool has_cameraname() const;
  inline void clear_cameraname();
  static const int kCameranameFieldNumber = 5;
  inline const ::std::string& cameraname() const;
  inline void set_cameraname(const ::std::string& value);
  inline void set_cameraname(const char* value);
  inline void set_cameraname(const char* value, size_t size);
  inline ::std::string* mutable_cameraname();
  inline ::std::string* release_cameraname();
  inline void set_allocated_cameraname(::std::string* cameraname);

  // optional bool hasrecjob = 6;
  inline bool has_hasrecjob() const;
  inline void clear_hasrecjob();
  static const int kHasrecjobFieldNumber = 6;
  inline bool hasrecjob() const;
  inline void set_hasrecjob(bool value);

  // optional bool recognizing = 7;
  inline bool has_recognizing() const;
  inline void clear_recognizing();
  static const int kRecognizingFieldNumber = 7;
  inline bool recognizing() const;
  inline void set_recognizing(bool value);

  // optional bool recognizing_flag = 8;
  inline bool has_recognizing_flag() const;
  inline void clear_recognizing_flag();
  static const int kRecognizingFlagFieldNumber = 8;
  inline bool recognizing_flag() const;
  inline void set_recognizing_flag(bool value);

  // optional int32 db_idcamera = 9;
  inline bool has_db_idcamera() const;
  inline void clear_db_idcamera();
  static const int kDbIdcameraFieldNumber = 9;
  inline ::google::protobuf::int32 db_idcamera() const;
  inline void set_db_idcamera(::google::protobuf::int32 value);

  // optional int32 db_idrec = 10;
  inline bool has_db_idrec() const;
  inline void clear_db_idrec();
  static const int kDbIdrecFieldNumber = 10;
  inline ::google::protobuf::int32 db_idrec() const;
  inline void set_db_idrec(::google::protobuf::int32 value);

  // optional bool fromdatabase = 11;
  inline bool has_fromdatabase() const;
  inline void clear_fromdatabase();
  static const int kFromdatabaseFieldNumber = 11;
  inline bool fromdatabase() const;
  inline void set_fromdatabase(bool value);

  // repeated .motion.Message.MotionTrack motiontrack = 12;
  inline int motiontrack_size() const;
  inline void clear_motiontrack();
  static const int kMotiontrackFieldNumber = 12;
  inline const ::motion::Message_MotionTrack& motiontrack(int index) const;
  inline ::motion::Message_MotionTrack* mutable_motiontrack(int index);
  inline ::motion::Message_MotionTrack* add_motiontrack();
  inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionTrack >&
      motiontrack() const;
  inline ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionTrack >*
      mutable_motiontrack();

  // optional int32 activemat = 13;
  inline bool has_activemat() const;
  inline void clear_activemat();
  static const int kActivematFieldNumber = 13;
  inline ::google::protobuf::int32 activemat() const;
  inline void set_activemat(::google::protobuf::int32 value);

  // optional int32 matcols = 14;
  inline bool has_matcols() const;
  inline void clear_matcols();
  static const int kMatcolsFieldNumber = 14;
  inline ::google::protobuf::int32 matcols() const;
  inline void set_matcols(::google::protobuf::int32 value);

  // optional int32 matrows = 15;
  inline bool has_matrows() const;
  inline void clear_matrows();
  static const int kMatrowsFieldNumber = 15;
  inline ::google::protobuf::int32 matrows() const;
  inline void set_matrows(::google::protobuf::int32 value);

  // optional int32 matwidth = 16;
  inline bool has_matwidth() const;
  inline void clear_matwidth();
  static const int kMatwidthFieldNumber = 16;
  inline ::google::protobuf::int32 matwidth() const;
  inline void set_matwidth(::google::protobuf::int32 value);

  // optional int32 matheight = 17;
  inline bool has_matheight() const;
  inline void clear_matheight();
  static const int kMatheightFieldNumber = 17;
  inline ::google::protobuf::int32 matheight() const;
  inline void set_matheight(::google::protobuf::int32 value);

  // optional int32 db_idmat = 18;
  inline bool has_db_idmat() const;
  inline void clear_db_idmat();
  static const int kDbIdmatFieldNumber = 18;
  inline ::google::protobuf::int32 db_idmat() const;
  inline void set_db_idmat(::google::protobuf::int32 value);

  // optional bytes tempdata = 19;
  inline bool has_tempdata() const;
  inline void clear_tempdata();
  static const int kTempdataFieldNumber = 19;
  inline const ::std::string& tempdata() const;
  inline void set_tempdata(const ::std::string& value);
  inline void set_tempdata(const char* value);
  inline void set_tempdata(const void* value, size_t size);
  inline ::std::string* mutable_tempdata();
  inline ::std::string* release_tempdata();
  inline void set_allocated_tempdata(::std::string* tempdata);

  // optional bytes thumbnail = 20;
  inline bool has_thumbnail() const;
  inline void clear_thumbnail();
  static const int kThumbnailFieldNumber = 20;
  inline const ::std::string& thumbnail() const;
  inline void set_thumbnail(const ::std::string& value);
  inline void set_thumbnail(const char* value);
  inline void set_thumbnail(const void* value, size_t size);
  inline ::std::string* mutable_thumbnail();
  inline ::std::string* release_thumbnail();
  inline void set_allocated_thumbnail(::std::string* thumbnail);

  // @@protoc_insertion_point(class_scope:motion.Message.MotionCamera)
 private:
  inline void set_has_cameraid();
  inline void clear_has_cameraid();
  inline void set_has_cameranumber();
  inline void clear_has_cameranumber();
  inline void set_has_cameraname();
  inline void clear_has_cameraname();
  inline void set_has_hasrecjob();
  inline void clear_has_hasrecjob();
  inline void set_has_recognizing();
  inline void clear_has_recognizing();
  inline void set_has_recognizing_flag();
  inline void clear_has_recognizing_flag();
  inline void set_has_db_idcamera();
  inline void clear_has_db_idcamera();
  inline void set_has_db_idrec();
  inline void clear_has_db_idrec();
  inline void set_has_fromdatabase();
  inline void clear_has_fromdatabase();
  inline void set_has_activemat();
  inline void clear_has_activemat();
  inline void set_has_matcols();
  inline void clear_has_matcols();
  inline void set_has_matrows();
  inline void clear_has_matrows();
  inline void set_has_matwidth();
  inline void clear_has_matwidth();
  inline void set_has_matheight();
  inline void clear_has_matheight();
  inline void set_has_db_idmat();
  inline void clear_has_db_idmat();
  inline void set_has_tempdata();
  inline void clear_has_tempdata();
  inline void set_has_thumbnail();
  inline void clear_has_thumbnail();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionMonth > motionmonth_;
  ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionRec > motionrec_;
  ::google::protobuf::int32 cameraid_;
  ::google::protobuf::int32 cameranumber_;
  ::std::string* cameraname_;
  bool hasrecjob_;
  bool recognizing_;
  bool recognizing_flag_;
  bool fromdatabase_;
  ::google::protobuf::int32 db_idcamera_;
  ::google::protobuf::int32 db_idrec_;
  ::google::protobuf::int32 activemat_;
  ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionTrack > motiontrack_;
  ::google::protobuf::int32 matcols_;
  ::google::protobuf::int32 matrows_;
  ::google::protobuf::int32 matwidth_;
  ::google::protobuf::int32 matheight_;
  ::std::string* tempdata_;
  ::std::string* thumbnail_;
  ::google::protobuf::int32 db_idmat_;
  friend void  protobuf_AddDesc_motion_2eproto();
  friend void protobuf_AssignDesc_motion_2eproto();
  friend void protobuf_ShutdownFile_motion_2eproto();

  void InitAsDefaultInstance();
  static Message_MotionCamera* default_instance_;
};
// -------------------------------------------------------------------

class Message_MotionTrack : public ::google::protobuf::Message {
 public:
  Message_MotionTrack();
  virtual ~Message_MotionTrack();

  Message_MotionTrack(const Message_MotionTrack& from);

  inline Message_MotionTrack& operator=(const Message_MotionTrack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_MotionTrack& default_instance();

  void Swap(Message_MotionTrack* other);

  // implements Message ----------------------------------------------

  Message_MotionTrack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_MotionTrack& from);
  void MergeFrom(const Message_MotionTrack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 db_idinstance = 1;
  inline bool has_db_idinstance() const;
  inline void clear_db_idinstance();
  static const int kDbIdinstanceFieldNumber = 1;
  inline ::google::protobuf::int32 db_idinstance() const;
  inline void set_db_idinstance(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:motion.Message.MotionTrack)
 private:
  inline void set_has_db_idinstance();
  inline void clear_has_db_idinstance();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 db_idinstance_;
  friend void  protobuf_AddDesc_motion_2eproto();
  friend void protobuf_AssignDesc_motion_2eproto();
  friend void protobuf_ShutdownFile_motion_2eproto();

  void InitAsDefaultInstance();
  static Message_MotionTrack* default_instance_;
};
// -------------------------------------------------------------------

class Message_MotionRec : public ::google::protobuf::Message {
 public:
  Message_MotionRec();
  virtual ~Message_MotionRec();

  Message_MotionRec(const Message_MotionRec& from);

  inline Message_MotionRec& operator=(const Message_MotionRec& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_MotionRec& default_instance();

  void Swap(Message_MotionRec* other);

  // implements Message ----------------------------------------------

  Message_MotionRec* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_MotionRec& from);
  void MergeFrom(const Message_MotionRec& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 db_idrec = 2;
  inline bool has_db_idrec() const;
  inline void clear_db_idrec();
  static const int kDbIdrecFieldNumber = 2;
  inline ::google::protobuf::int32 db_idrec() const;
  inline void set_db_idrec(::google::protobuf::int32 value);

  // optional string timestart = 3;
  inline bool has_timestart() const;
  inline void clear_timestart();
  static const int kTimestartFieldNumber = 3;
  inline const ::std::string& timestart() const;
  inline void set_timestart(const ::std::string& value);
  inline void set_timestart(const char* value);
  inline void set_timestart(const char* value, size_t size);
  inline ::std::string* mutable_timestart();
  inline ::std::string* release_timestart();
  inline void set_allocated_timestart(::std::string* timestart);

  // optional string timeend = 4;
  inline bool has_timeend() const;
  inline void clear_timeend();
  static const int kTimeendFieldNumber = 4;
  inline const ::std::string& timeend() const;
  inline void set_timeend(const ::std::string& value);
  inline void set_timeend(const char* value);
  inline void set_timeend(const char* value, size_t size);
  inline ::std::string* mutable_timeend();
  inline ::std::string* release_timeend();
  inline void set_allocated_timeend(::std::string* timeend);

  // optional string recname = 5;
  inline bool has_recname() const;
  inline void clear_recname();
  static const int kRecnameFieldNumber = 5;
  inline const ::std::string& recname() const;
  inline void set_recname(const ::std::string& value);
  inline void set_recname(const char* value);
  inline void set_recname(const char* value, size_t size);
  inline ::std::string* mutable_recname();
  inline ::std::string* release_recname();
  inline void set_allocated_recname(::std::string* recname);

  // optional string camerasince = 6;
  inline bool has_camerasince() const;
  inline void clear_camerasince();
  static const int kCamerasinceFieldNumber = 6;
  inline const ::std::string& camerasince() const;
  inline void set_camerasince(const ::std::string& value);
  inline void set_camerasince(const char* value);
  inline void set_camerasince(const char* value, size_t size);
  inline ::std::string* mutable_camerasince();
  inline ::std::string* release_camerasince();
  inline void set_allocated_camerasince(::std::string* camerasince);

  // optional bool storeimage = 7;
  inline bool has_storeimage() const;
  inline void clear_storeimage();
  static const int kStoreimageFieldNumber = 7;
  inline bool storeimage() const;
  inline void set_storeimage(bool value);

  // optional bool storevideo = 8;
  inline bool has_storevideo() const;
  inline void clear_storevideo();
  static const int kStorevideoFieldNumber = 8;
  inline bool storevideo() const;
  inline void set_storevideo(bool value);

  // optional string codename = 9;
  inline bool has_codename() const;
  inline void clear_codename();
  static const int kCodenameFieldNumber = 9;
  inline const ::std::string& codename() const;
  inline void set_codename(const ::std::string& value);
  inline void set_codename(const char* value);
  inline void set_codename(const char* value, size_t size);
  inline ::std::string* mutable_codename();
  inline ::std::string* release_codename();
  inline void set_allocated_codename(::std::string* codename);

  // optional bool hasregion = 10;
  inline bool has_hasregion() const;
  inline void clear_hasregion();
  static const int kHasregionFieldNumber = 10;
  inline bool hasregion() const;
  inline void set_hasregion(bool value);

  // optional string coordinates = 11;
  inline bool has_coordinates() const;
  inline void clear_coordinates();
  static const int kCoordinatesFieldNumber = 11;
  inline const ::std::string& coordinates() const;
  inline void set_coordinates(const ::std::string& value);
  inline void set_coordinates(const char* value);
  inline void set_coordinates(const char* value, size_t size);
  inline ::std::string* mutable_coordinates();
  inline ::std::string* release_coordinates();
  inline void set_allocated_coordinates(::std::string* coordinates);

  // optional int32 delay = 12;
  inline bool has_delay() const;
  inline void clear_delay();
  static const int kDelayFieldNumber = 12;
  inline ::google::protobuf::int32 delay() const;
  inline void set_delay(::google::protobuf::int32 value);

  // optional string startrectime = 13;
  inline bool has_startrectime() const;
  inline void clear_startrectime();
  static const int kStartrectimeFieldNumber = 13;
  inline const ::std::string& startrectime() const;
  inline void set_startrectime(const ::std::string& value);
  inline void set_startrectime(const char* value);
  inline void set_startrectime(const char* value, size_t size);
  inline ::std::string* mutable_startrectime();
  inline ::std::string* release_startrectime();
  inline void set_allocated_startrectime(::std::string* startrectime);

  // optional string stoprectime = 14;
  inline bool has_stoprectime() const;
  inline void clear_stoprectime();
  static const int kStoprectimeFieldNumber = 14;
  inline const ::std::string& stoprectime() const;
  inline void set_stoprectime(const ::std::string& value);
  inline void set_stoprectime(const char* value);
  inline void set_stoprectime(const char* value, size_t size);
  inline ::std::string* mutable_stoprectime();
  inline ::std::string* release_stoprectime();
  inline void set_allocated_stoprectime(::std::string* stoprectime);

  // optional bool runatstartup = 15;
  inline bool has_runatstartup() const;
  inline void clear_runatstartup();
  static const int kRunatstartupFieldNumber = 15;
  inline bool runatstartup() const;
  inline void set_runatstartup(bool value);

  // optional int32 activemat = 16;
  inline bool has_activemat() const;
  inline void clear_activemat();
  static const int kActivematFieldNumber = 16;
  inline ::google::protobuf::int32 activemat() const;
  inline void set_activemat(::google::protobuf::int32 value);

  // optional int32 db_idmat = 17;
  inline bool has_db_idmat() const;
  inline void clear_db_idmat();
  static const int kDbIdmatFieldNumber = 17;
  inline ::google::protobuf::int32 db_idmat() const;
  inline void set_db_idmat(::google::protobuf::int32 value);

  // optional int32 db_idcoordinates = 18;
  inline bool has_db_idcoordinates() const;
  inline void clear_db_idcoordinates();
  static const int kDbIdcoordinatesFieldNumber = 18;
  inline ::google::protobuf::int32 db_idcoordinates() const;
  inline void set_db_idcoordinates(::google::protobuf::int32 value);

  // optional int32 db_intervalid = 19;
  inline bool has_db_intervalid() const;
  inline void clear_db_intervalid();
  static const int kDbIntervalidFieldNumber = 19;
  inline ::google::protobuf::int32 db_intervalid() const;
  inline void set_db_intervalid(::google::protobuf::int32 value);

  // optional int32 matcols = 20;
  inline bool has_matcols() const;
  inline void clear_matcols();
  static const int kMatcolsFieldNumber = 20;
  inline ::google::protobuf::int32 matcols() const;
  inline void set_matcols(::google::protobuf::int32 value);

  // optional int32 matrows = 21;
  inline bool has_matrows() const;
  inline void clear_matrows();
  static const int kMatrowsFieldNumber = 21;
  inline ::google::protobuf::int32 matrows() const;
  inline void set_matrows(::google::protobuf::int32 value);

  // optional int32 matwidth = 22;
  inline bool has_matwidth() const;
  inline void clear_matwidth();
  static const int kMatwidthFieldNumber = 22;
  inline ::google::protobuf::int32 matwidth() const;
  inline void set_matwidth(::google::protobuf::int32 value);

  // optional int32 matheight = 23;
  inline bool has_matheight() const;
  inline void clear_matheight();
  static const int kMatheightFieldNumber = 23;
  inline ::google::protobuf::int32 matheight() const;
  inline void set_matheight(::google::protobuf::int32 value);

  // optional string lastinstance = 24;
  inline bool has_lastinstance() const;
  inline void clear_lastinstance();
  static const int kLastinstanceFieldNumber = 24;
  inline const ::std::string& lastinstance() const;
  inline void set_lastinstance(const ::std::string& value);
  inline void set_lastinstance(const char* value);
  inline void set_lastinstance(const char* value, size_t size);
  inline ::std::string* mutable_lastinstance();
  inline ::std::string* release_lastinstance();
  inline void set_allocated_lastinstance(::std::string* lastinstance);

  // optional int32 db_idmonth = 25;
  inline bool has_db_idmonth() const;
  inline void clear_db_idmonth();
  static const int kDbIdmonthFieldNumber = 25;
  inline ::google::protobuf::int32 db_idmonth() const;
  inline void set_db_idmonth(::google::protobuf::int32 value);

  // optional int32 db_idday = 26;
  inline bool has_db_idday() const;
  inline void clear_db_idday();
  static const int kDbIddayFieldNumber = 26;
  inline ::google::protobuf::int32 db_idday() const;
  inline void set_db_idday(::google::protobuf::int32 value);

  // optional string xmlfilepath = 27;
  inline bool has_xmlfilepath() const;
  inline void clear_xmlfilepath();
  static const int kXmlfilepathFieldNumber = 27;
  inline const ::std::string& xmlfilepath() const;
  inline void set_xmlfilepath(const ::std::string& value);
  inline void set_xmlfilepath(const char* value);
  inline void set_xmlfilepath(const char* value, size_t size);
  inline ::std::string* mutable_xmlfilepath();
  inline ::std::string* release_xmlfilepath();
  inline void set_allocated_xmlfilepath(::std::string* xmlfilepath);

  // optional int32 db_recognitionsetupid = 28;
  inline bool has_db_recognitionsetupid() const;
  inline void clear_db_recognitionsetupid();
  static const int kDbRecognitionsetupidFieldNumber = 28;
  inline ::google::protobuf::int32 db_recognitionsetupid() const;
  inline void set_db_recognitionsetupid(::google::protobuf::int32 value);

  // optional bool hascron = 29;
  inline bool has_hascron() const;
  inline void clear_hascron();
  static const int kHascronFieldNumber = 29;
  inline bool hascron() const;
  inline void set_hascron(bool value);

  // repeated .motion.Message.MotionCron motioncron = 30;
  inline int motioncron_size() const;
  inline void clear_motioncron();
  static const int kMotioncronFieldNumber = 30;
  inline const ::motion::Message_MotionCron& motioncron(int index) const;
  inline ::motion::Message_MotionCron* mutable_motioncron(int index);
  inline ::motion::Message_MotionCron* add_motioncron();
  inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionCron >&
      motioncron() const;
  inline ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionCron >*
      mutable_motioncron();

  // optional int32 speed = 31;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 31;
  inline ::google::protobuf::int32 speed() const;
  inline void set_speed(::google::protobuf::int32 value);

  // optional int32 activerec = 32;
  inline bool has_activerec() const;
  inline void clear_activerec();
  static const int kActiverecFieldNumber = 32;
  inline ::google::protobuf::int32 activerec() const;
  inline void set_activerec(::google::protobuf::int32 value);

  // optional string matbasefile = 33;
  inline bool has_matbasefile() const;
  inline void clear_matbasefile();
  static const int kMatbasefileFieldNumber = 33;
  inline const ::std::string& matbasefile() const;
  inline void set_matbasefile(const ::std::string& value);
  inline void set_matbasefile(const char* value);
  inline void set_matbasefile(const char* value, size_t size);
  inline ::std::string* mutable_matbasefile();
  inline ::std::string* release_matbasefile();
  inline void set_allocated_matbasefile(::std::string* matbasefile);

  // optional string created = 34;
  inline bool has_created() const;
  inline void clear_created();
  static const int kCreatedFieldNumber = 34;
  inline const ::std::string& created() const;
  inline void set_created(const ::std::string& value);
  inline void set_created(const char* value);
  inline void set_created(const char* value, size_t size);
  inline ::std::string* mutable_created();
  inline ::std::string* release_created();
  inline void set_allocated_created(::std::string* created);

  // @@protoc_insertion_point(class_scope:motion.Message.MotionRec)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_db_idrec();
  inline void clear_has_db_idrec();
  inline void set_has_timestart();
  inline void clear_has_timestart();
  inline void set_has_timeend();
  inline void clear_has_timeend();
  inline void set_has_recname();
  inline void clear_has_recname();
  inline void set_has_camerasince();
  inline void clear_has_camerasince();
  inline void set_has_storeimage();
  inline void clear_has_storeimage();
  inline void set_has_storevideo();
  inline void clear_has_storevideo();
  inline void set_has_codename();
  inline void clear_has_codename();
  inline void set_has_hasregion();
  inline void clear_has_hasregion();
  inline void set_has_coordinates();
  inline void clear_has_coordinates();
  inline void set_has_delay();
  inline void clear_has_delay();
  inline void set_has_startrectime();
  inline void clear_has_startrectime();
  inline void set_has_stoprectime();
  inline void clear_has_stoprectime();
  inline void set_has_runatstartup();
  inline void clear_has_runatstartup();
  inline void set_has_activemat();
  inline void clear_has_activemat();
  inline void set_has_db_idmat();
  inline void clear_has_db_idmat();
  inline void set_has_db_idcoordinates();
  inline void clear_has_db_idcoordinates();
  inline void set_has_db_intervalid();
  inline void clear_has_db_intervalid();
  inline void set_has_matcols();
  inline void clear_has_matcols();
  inline void set_has_matrows();
  inline void clear_has_matrows();
  inline void set_has_matwidth();
  inline void clear_has_matwidth();
  inline void set_has_matheight();
  inline void clear_has_matheight();
  inline void set_has_lastinstance();
  inline void clear_has_lastinstance();
  inline void set_has_db_idmonth();
  inline void clear_has_db_idmonth();
  inline void set_has_db_idday();
  inline void clear_has_db_idday();
  inline void set_has_xmlfilepath();
  inline void clear_has_xmlfilepath();
  inline void set_has_db_recognitionsetupid();
  inline void clear_has_db_recognitionsetupid();
  inline void set_has_hascron();
  inline void clear_has_hascron();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_activerec();
  inline void clear_has_activerec();
  inline void set_has_matbasefile();
  inline void clear_has_matbasefile();
  inline void set_has_created();
  inline void clear_has_created();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[2];
  ::std::string* name_;
  ::std::string* timestart_;
  ::std::string* timeend_;
  ::std::string* recname_;
  ::std::string* camerasince_;
  ::google::protobuf::int32 db_idrec_;
  bool storeimage_;
  bool storevideo_;
  bool hasregion_;
  bool runatstartup_;
  ::std::string* codename_;
  ::std::string* coordinates_;
  ::std::string* startrectime_;
  ::std::string* stoprectime_;
  ::google::protobuf::int32 delay_;
  ::google::protobuf::int32 activemat_;
  ::google::protobuf::int32 db_idmat_;
  ::google::protobuf::int32 db_idcoordinates_;
  ::google::protobuf::int32 db_intervalid_;
  ::google::protobuf::int32 matcols_;
  ::google::protobuf::int32 matrows_;
  ::google::protobuf::int32 matwidth_;
  ::std::string* lastinstance_;
  ::google::protobuf::int32 matheight_;
  ::google::protobuf::int32 db_idmonth_;
  ::std::string* xmlfilepath_;
  ::google::protobuf::int32 db_idday_;
  ::google::protobuf::int32 db_recognitionsetupid_;
  ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionCron > motioncron_;
  bool hascron_;
  ::google::protobuf::int32 speed_;
  ::std::string* matbasefile_;
  ::std::string* created_;
  ::google::protobuf::int32 activerec_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_motion_2eproto();
  friend void protobuf_AssignDesc_motion_2eproto();
  friend void protobuf_ShutdownFile_motion_2eproto();

  void InitAsDefaultInstance();
  static Message_MotionRec* default_instance_;
};
// -------------------------------------------------------------------

class Message_MotionCron : public ::google::protobuf::Message {
 public:
  Message_MotionCron();
  virtual ~Message_MotionCron();

  Message_MotionCron(const Message_MotionCron& from);

  inline Message_MotionCron& operator=(const Message_MotionCron& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_MotionCron& default_instance();

  void Swap(Message_MotionCron* other);

  // implements Message ----------------------------------------------

  Message_MotionCron* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_MotionCron& from);
  void MergeFrom(const Message_MotionCron& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string command = 1;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline const ::std::string& command() const;
  inline void set_command(const ::std::string& value);
  inline void set_command(const char* value);
  inline void set_command(const char* value, size_t size);
  inline ::std::string* mutable_command();
  inline ::std::string* release_command();
  inline void set_allocated_command(::std::string* command);

  // optional string program = 2;
  inline bool has_program() const;
  inline void clear_program();
  static const int kProgramFieldNumber = 2;
  inline const ::std::string& program() const;
  inline void set_program(const ::std::string& value);
  inline void set_program(const char* value);
  inline void set_program(const char* value, size_t size);
  inline ::std::string* mutable_program();
  inline ::std::string* release_program();
  inline void set_allocated_program(::std::string* program);

  // @@protoc_insertion_point(class_scope:motion.Message.MotionCron)
 private:
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_program();
  inline void clear_has_program();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* command_;
  ::std::string* program_;
  friend void  protobuf_AddDesc_motion_2eproto();
  friend void protobuf_AssignDesc_motion_2eproto();
  friend void protobuf_ShutdownFile_motion_2eproto();

  void InitAsDefaultInstance();
  static Message_MotionCron* default_instance_;
};
// -------------------------------------------------------------------

class Message_MotionMonth : public ::google::protobuf::Message {
 public:
  Message_MotionMonth();
  virtual ~Message_MotionMonth();

  Message_MotionMonth(const Message_MotionMonth& from);

  inline Message_MotionMonth& operator=(const Message_MotionMonth& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_MotionMonth& default_instance();

  void Swap(Message_MotionMonth* other);

  // implements Message ----------------------------------------------

  Message_MotionMonth* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_MotionMonth& from);
  void MergeFrom(const Message_MotionMonth& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .motion.Message.MotionDay motionday = 1;
  inline int motionday_size() const;
  inline void clear_motionday();
  static const int kMotiondayFieldNumber = 1;
  inline const ::motion::Message_MotionDay& motionday(int index) const;
  inline ::motion::Message_MotionDay* mutable_motionday(int index);
  inline ::motion::Message_MotionDay* add_motionday();
  inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionDay >&
      motionday() const;
  inline ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionDay >*
      mutable_motionday();

  // optional string monthlabel = 2;
  inline bool has_monthlabel() const;
  inline void clear_monthlabel();
  static const int kMonthlabelFieldNumber = 2;
  inline const ::std::string& monthlabel() const;
  inline void set_monthlabel(const ::std::string& value);
  inline void set_monthlabel(const char* value);
  inline void set_monthlabel(const char* value, size_t size);
  inline ::std::string* mutable_monthlabel();
  inline ::std::string* release_monthlabel();
  inline void set_allocated_monthlabel(::std::string* monthlabel);

  // optional int32 db_monthid = 3;
  inline bool has_db_monthid() const;
  inline void clear_db_monthid();
  static const int kDbMonthidFieldNumber = 3;
  inline ::google::protobuf::int32 db_monthid() const;
  inline void set_db_monthid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:motion.Message.MotionMonth)
 private:
  inline void set_has_monthlabel();
  inline void clear_has_monthlabel();
  inline void set_has_db_monthid();
  inline void clear_has_db_monthid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionDay > motionday_;
  ::std::string* monthlabel_;
  ::google::protobuf::int32 db_monthid_;
  friend void  protobuf_AddDesc_motion_2eproto();
  friend void protobuf_AssignDesc_motion_2eproto();
  friend void protobuf_ShutdownFile_motion_2eproto();

  void InitAsDefaultInstance();
  static Message_MotionMonth* default_instance_;
};
// -------------------------------------------------------------------

class Message_MotionDay : public ::google::protobuf::Message {
 public:
  Message_MotionDay();
  virtual ~Message_MotionDay();

  Message_MotionDay(const Message_MotionDay& from);

  inline Message_MotionDay& operator=(const Message_MotionDay& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_MotionDay& default_instance();

  void Swap(Message_MotionDay* other);

  // implements Message ----------------------------------------------

  Message_MotionDay* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_MotionDay& from);
  void MergeFrom(const Message_MotionDay& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .motion.Message.Instance instance = 1;
  inline int instance_size() const;
  inline void clear_instance();
  static const int kInstanceFieldNumber = 1;
  inline const ::motion::Message_Instance& instance(int index) const;
  inline ::motion::Message_Instance* mutable_instance(int index);
  inline ::motion::Message_Instance* add_instance();
  inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_Instance >&
      instance() const;
  inline ::google::protobuf::RepeatedPtrField< ::motion::Message_Instance >*
      mutable_instance();

  // optional string daylabel = 2;
  inline bool has_daylabel() const;
  inline void clear_daylabel();
  static const int kDaylabelFieldNumber = 2;
  inline const ::std::string& daylabel() const;
  inline void set_daylabel(const ::std::string& value);
  inline void set_daylabel(const char* value);
  inline void set_daylabel(const char* value, size_t size);
  inline ::std::string* mutable_daylabel();
  inline ::std::string* release_daylabel();
  inline void set_allocated_daylabel(::std::string* daylabel);

  // optional int32 db_dayid = 3;
  inline bool has_db_dayid() const;
  inline void clear_db_dayid();
  static const int kDbDayidFieldNumber = 3;
  inline ::google::protobuf::int32 db_dayid() const;
  inline void set_db_dayid(::google::protobuf::int32 value);

  // optional string xmlfilepath = 4;
  inline bool has_xmlfilepath() const;
  inline void clear_xmlfilepath();
  static const int kXmlfilepathFieldNumber = 4;
  inline const ::std::string& xmlfilepath() const;
  inline void set_xmlfilepath(const ::std::string& value);
  inline void set_xmlfilepath(const char* value);
  inline void set_xmlfilepath(const char* value, size_t size);
  inline ::std::string* mutable_xmlfilepath();
  inline ::std::string* release_xmlfilepath();
  inline void set_allocated_xmlfilepath(::std::string* xmlfilepath);

  // optional string title = 5;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 5;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // @@protoc_insertion_point(class_scope:motion.Message.MotionDay)
 private:
  inline void set_has_daylabel();
  inline void clear_has_daylabel();
  inline void set_has_db_dayid();
  inline void clear_has_db_dayid();
  inline void set_has_xmlfilepath();
  inline void clear_has_xmlfilepath();
  inline void set_has_title();
  inline void clear_has_title();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::motion::Message_Instance > instance_;
  ::std::string* daylabel_;
  ::std::string* xmlfilepath_;
  ::std::string* title_;
  ::google::protobuf::int32 db_dayid_;
  friend void  protobuf_AddDesc_motion_2eproto();
  friend void protobuf_AssignDesc_motion_2eproto();
  friend void protobuf_ShutdownFile_motion_2eproto();

  void InitAsDefaultInstance();
  static Message_MotionDay* default_instance_;
};
// -------------------------------------------------------------------

class Message_Instance : public ::google::protobuf::Message {
 public:
  Message_Instance();
  virtual ~Message_Instance();

  Message_Instance(const Message_Instance& from);

  inline Message_Instance& operator=(const Message_Instance& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_Instance& default_instance();

  void Swap(Message_Instance* other);

  // implements Message ----------------------------------------------

  Message_Instance* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_Instance& from);
  void MergeFrom(const Message_Instance& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 idinstance = 1;
  inline bool has_idinstance() const;
  inline void clear_idinstance();
  static const int kIdinstanceFieldNumber = 1;
  inline ::google::protobuf::int32 idinstance() const;
  inline void set_idinstance(::google::protobuf::int32 value);

  // optional int32 number = 2;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 2;
  inline ::google::protobuf::int32 number() const;
  inline void set_number(::google::protobuf::int32 value);

  // optional string instancestart = 3;
  inline bool has_instancestart() const;
  inline void clear_instancestart();
  static const int kInstancestartFieldNumber = 3;
  inline const ::std::string& instancestart() const;
  inline void set_instancestart(const ::std::string& value);
  inline void set_instancestart(const char* value);
  inline void set_instancestart(const char* value, size_t size);
  inline ::std::string* mutable_instancestart();
  inline ::std::string* release_instancestart();
  inline void set_allocated_instancestart(::std::string* instancestart);

  // optional string instanceend = 4;
  inline bool has_instanceend() const;
  inline void clear_instanceend();
  static const int kInstanceendFieldNumber = 4;
  inline const ::std::string& instanceend() const;
  inline void set_instanceend(const ::std::string& value);
  inline void set_instanceend(const char* value);
  inline void set_instanceend(const char* value, size_t size);
  inline ::std::string* mutable_instanceend();
  inline ::std::string* release_instanceend();
  inline void set_allocated_instanceend(::std::string* instanceend);

  // optional string fileformat = 5;
  inline bool has_fileformat() const;
  inline void clear_fileformat();
  static const int kFileformatFieldNumber = 5;
  inline const ::std::string& fileformat() const;
  inline void set_fileformat(const ::std::string& value);
  inline void set_fileformat(const char* value);
  inline void set_fileformat(const char* value, size_t size);
  inline ::std::string* mutable_fileformat();
  inline ::std::string* release_fileformat();
  inline void set_allocated_fileformat(::std::string* fileformat);

  // repeated .motion.Message.Image image = 6;
  inline int image_size() const;
  inline void clear_image();
  static const int kImageFieldNumber = 6;
  inline const ::motion::Message_Image& image(int index) const;
  inline ::motion::Message_Image* mutable_image(int index);
  inline ::motion::Message_Image* add_image();
  inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_Image >&
      image() const;
  inline ::google::protobuf::RepeatedPtrField< ::motion::Message_Image >*
      mutable_image();

  // repeated .motion.Message.Crop crop = 7;
  inline int crop_size() const;
  inline void clear_crop();
  static const int kCropFieldNumber = 7;
  inline const ::motion::Message_Crop& crop(int index) const;
  inline ::motion::Message_Crop* mutable_crop(int index);
  inline ::motion::Message_Crop* add_crop();
  inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_Crop >&
      crop() const;
  inline ::google::protobuf::RepeatedPtrField< ::motion::Message_Crop >*
      mutable_crop();

  // optional .motion.Message.Video video = 8;
  inline bool has_video() const;
  inline void clear_video();
  static const int kVideoFieldNumber = 8;
  inline const ::motion::Message_Video& video() const;
  inline ::motion::Message_Video* mutable_video();
  inline ::motion::Message_Video* release_video();
  inline void set_allocated_video(::motion::Message_Video* video);

  // optional string dir = 9;
  inline bool has_dir() const;
  inline void clear_dir();
  static const int kDirFieldNumber = 9;
  inline const ::std::string& dir() const;
  inline void set_dir(const ::std::string& value);
  inline void set_dir(const char* value);
  inline void set_dir(const char* value, size_t size);
  inline ::std::string* mutable_dir();
  inline ::std::string* release_dir();
  inline void set_allocated_dir(::std::string* dir);

  // optional string xmlfile = 10;
  inline bool has_xmlfile() const;
  inline void clear_xmlfile();
  static const int kXmlfileFieldNumber = 10;
  inline const ::std::string& xmlfile() const;
  inline void set_xmlfile(const ::std::string& value);
  inline void set_xmlfile(const char* value);
  inline void set_xmlfile(const char* value, size_t size);
  inline ::std::string* mutable_xmlfile();
  inline ::std::string* release_xmlfile();
  inline void set_allocated_xmlfile(::std::string* xmlfile);

  // optional string extdata = 11;
  inline bool has_extdata() const;
  inline void clear_extdata();
  static const int kExtdataFieldNumber = 11;
  inline const ::std::string& extdata() const;
  inline void set_extdata(const ::std::string& value);
  inline void set_extdata(const char* value);
  inline void set_extdata(const char* value, size_t size);
  inline ::std::string* mutable_extdata();
  inline ::std::string* release_extdata();
  inline void set_allocated_extdata(::std::string* extdata);

  // optional string end = 12;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 12;
  inline const ::std::string& end() const;
  inline void set_end(const ::std::string& value);
  inline void set_end(const char* value);
  inline void set_end(const char* value, size_t size);
  inline ::std::string* mutable_end();
  inline ::std::string* release_end();
  inline void set_allocated_end(::std::string* end);

  // optional int32 begintime = 13;
  inline bool has_begintime() const;
  inline void clear_begintime();
  static const int kBegintimeFieldNumber = 13;
  inline ::google::protobuf::int32 begintime() const;
  inline void set_begintime(::google::protobuf::int32 value);

  // optional int32 endtime = 14;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 14;
  inline ::google::protobuf::int32 endtime() const;
  inline void set_endtime(::google::protobuf::int32 value);

  // optional int32 inittime = 15;
  inline bool has_inittime() const;
  inline void clear_inittime();
  static const int kInittimeFieldNumber = 15;
  inline ::google::protobuf::int32 inittime() const;
  inline void set_inittime(::google::protobuf::int32 value);

  // optional string instance = 16;
  inline bool has_instance() const;
  inline void clear_instance();
  static const int kInstanceFieldNumber = 16;
  inline const ::std::string& instance() const;
  inline void set_instance(const ::std::string& value);
  inline void set_instance(const char* value);
  inline void set_instance(const char* value, size_t size);
  inline ::std::string* mutable_instance();
  inline ::std::string* release_instance();
  inline void set_allocated_instance(::std::string* instance);

  // optional string instancecode = 17;
  inline bool has_instancecode() const;
  inline void clear_instancecode();
  static const int kInstancecodeFieldNumber = 17;
  inline const ::std::string& instancecode() const;
  inline void set_instancecode(const ::std::string& value);
  inline void set_instancecode(const char* value);
  inline void set_instancecode(const char* value, size_t size);
  inline ::std::string* mutable_instancecode();
  inline ::std::string* release_instancecode();
  inline void set_allocated_instancecode(::std::string* instancecode);

  // optional string timeinfo = 18;
  inline bool has_timeinfo() const;
  inline void clear_timeinfo();
  static const int kTimeinfoFieldNumber = 18;
  inline const ::std::string& timeinfo() const;
  inline void set_timeinfo(const ::std::string& value);
  inline void set_timeinfo(const char* value);
  inline void set_timeinfo(const char* value, size_t size);
  inline ::std::string* mutable_timeinfo();
  inline ::std::string* release_timeinfo();
  inline void set_allocated_timeinfo(::std::string* timeinfo);

  // optional int32 db_dayid = 19;
  inline bool has_db_dayid() const;
  inline void clear_db_dayid();
  static const int kDbDayidFieldNumber = 19;
  inline ::google::protobuf::int32 db_dayid() const;
  inline void set_db_dayid(::google::protobuf::int32 value);

  // optional int32 db_recognition_setup_id = 20;
  inline bool has_db_recognition_setup_id() const;
  inline void clear_db_recognition_setup_id();
  static const int kDbRecognitionSetupIdFieldNumber = 20;
  inline ::google::protobuf::int32 db_recognition_setup_id() const;
  inline void set_db_recognition_setup_id(::google::protobuf::int32 value);

  // optional string recname = 21;
  inline bool has_recname() const;
  inline void clear_recname();
  static const int kRecnameFieldNumber = 21;
  inline const ::std::string& recname() const;
  inline void set_recname(const ::std::string& value);
  inline void set_recname(const char* value);
  inline void set_recname(const char* value, size_t size);
  inline ::std::string* mutable_recname();
  inline ::std::string* release_recname();
  inline void set_allocated_recname(::std::string* recname);

  // optional string camera = 22;
  inline bool has_camera() const;
  inline void clear_camera();
  static const int kCameraFieldNumber = 22;
  inline const ::std::string& camera() const;
  inline void set_camera(const ::std::string& value);
  inline void set_camera(const char* value);
  inline void set_camera(const char* value, size_t size);
  inline ::std::string* mutable_camera();
  inline ::std::string* release_camera();
  inline void set_allocated_camera(::std::string* camera);

  // optional int32 cameranumber = 23;
  inline bool has_cameranumber() const;
  inline void clear_cameranumber();
  static const int kCameranumberFieldNumber = 23;
  inline ::google::protobuf::int32 cameranumber() const;
  inline void set_cameranumber(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:motion.Message.Instance)
 private:
  inline void set_has_idinstance();
  inline void clear_has_idinstance();
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_instancestart();
  inline void clear_has_instancestart();
  inline void set_has_instanceend();
  inline void clear_has_instanceend();
  inline void set_has_fileformat();
  inline void clear_has_fileformat();
  inline void set_has_video();
  inline void clear_has_video();
  inline void set_has_dir();
  inline void clear_has_dir();
  inline void set_has_xmlfile();
  inline void clear_has_xmlfile();
  inline void set_has_extdata();
  inline void clear_has_extdata();
  inline void set_has_end();
  inline void clear_has_end();
  inline void set_has_begintime();
  inline void clear_has_begintime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_inittime();
  inline void clear_has_inittime();
  inline void set_has_instance();
  inline void clear_has_instance();
  inline void set_has_instancecode();
  inline void clear_has_instancecode();
  inline void set_has_timeinfo();
  inline void clear_has_timeinfo();
  inline void set_has_db_dayid();
  inline void clear_has_db_dayid();
  inline void set_has_db_recognition_setup_id();
  inline void clear_has_db_recognition_setup_id();
  inline void set_has_recname();
  inline void clear_has_recname();
  inline void set_has_camera();
  inline void clear_has_camera();
  inline void set_has_cameranumber();
  inline void clear_has_cameranumber();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 idinstance_;
  ::google::protobuf::int32 number_;
  ::std::string* instancestart_;
  ::std::string* instanceend_;
  ::std::string* fileformat_;
  ::google::protobuf::RepeatedPtrField< ::motion::Message_Image > image_;
  ::google::protobuf::RepeatedPtrField< ::motion::Message_Crop > crop_;
  ::motion::Message_Video* video_;
  ::std::string* dir_;
  ::std::string* xmlfile_;
  ::std::string* extdata_;
  ::std::string* end_;
  ::google::protobuf::int32 begintime_;
  ::google::protobuf::int32 endtime_;
  ::std::string* instance_;
  ::std::string* instancecode_;
  ::google::protobuf::int32 inittime_;
  ::google::protobuf::int32 db_dayid_;
  ::std::string* timeinfo_;
  ::std::string* recname_;
  ::google::protobuf::int32 db_recognition_setup_id_;
  ::google::protobuf::int32 cameranumber_;
  ::std::string* camera_;
  friend void  protobuf_AddDesc_motion_2eproto();
  friend void protobuf_AssignDesc_motion_2eproto();
  friend void protobuf_ShutdownFile_motion_2eproto();

  void InitAsDefaultInstance();
  static Message_Instance* default_instance_;
};
// -------------------------------------------------------------------

class Message_Image : public ::google::protobuf::Message {
 public:
  Message_Image();
  virtual ~Message_Image();

  Message_Image(const Message_Image& from);

  inline Message_Image& operator=(const Message_Image& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_Image& default_instance();

  void Swap(Message_Image* other);

  // implements Message ----------------------------------------------

  Message_Image* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_Image& from);
  void MergeFrom(const Message_Image& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 imagechanges = 3;
  inline bool has_imagechanges() const;
  inline void clear_imagechanges();
  static const int kImagechangesFieldNumber = 3;
  inline ::google::protobuf::int32 imagechanges() const;
  inline void set_imagechanges(::google::protobuf::int32 value);

  // optional string time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // @@protoc_insertion_point(class_scope:motion.Message.Image)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_imagechanges();
  inline void clear_has_imagechanges();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* path_;
  ::std::string* name_;
  ::std::string* time_;
  ::google::protobuf::int32 imagechanges_;
  friend void  protobuf_AddDesc_motion_2eproto();
  friend void protobuf_AssignDesc_motion_2eproto();
  friend void protobuf_ShutdownFile_motion_2eproto();

  void InitAsDefaultInstance();
  static Message_Image* default_instance_;
};
// -------------------------------------------------------------------

class Message_Crop : public ::google::protobuf::Message {
 public:
  Message_Crop();
  virtual ~Message_Crop();

  Message_Crop(const Message_Crop& from);

  inline Message_Crop& operator=(const Message_Crop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_Crop& default_instance();

  void Swap(Message_Crop* other);

  // implements Message ----------------------------------------------

  Message_Crop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_Crop& from);
  void MergeFrom(const Message_Crop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string rect = 1;
  inline bool has_rect() const;
  inline void clear_rect();
  static const int kRectFieldNumber = 1;
  inline const ::std::string& rect() const;
  inline void set_rect(const ::std::string& value);
  inline void set_rect(const char* value);
  inline void set_rect(const char* value, size_t size);
  inline ::std::string* mutable_rect();
  inline ::std::string* release_rect();
  inline void set_allocated_rect(::std::string* rect);

  // optional int32 db_imagefatherid = 2;
  inline bool has_db_imagefatherid() const;
  inline void clear_db_imagefatherid();
  static const int kDbImagefatheridFieldNumber = 2;
  inline ::google::protobuf::int32 db_imagefatherid() const;
  inline void set_db_imagefatherid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:motion.Message.Crop)
 private:
  inline void set_has_rect();
  inline void clear_has_rect();
  inline void set_has_db_imagefatherid();
  inline void clear_has_db_imagefatherid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* rect_;
  ::google::protobuf::int32 db_imagefatherid_;
  friend void  protobuf_AddDesc_motion_2eproto();
  friend void protobuf_AssignDesc_motion_2eproto();
  friend void protobuf_ShutdownFile_motion_2eproto();

  void InitAsDefaultInstance();
  static Message_Crop* default_instance_;
};
// -------------------------------------------------------------------

class Message_Video : public ::google::protobuf::Message {
 public:
  Message_Video();
  virtual ~Message_Video();

  Message_Video(const Message_Video& from);

  inline Message_Video& operator=(const Message_Video& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_Video& default_instance();

  void Swap(Message_Video* other);

  // implements Message ----------------------------------------------

  Message_Video* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_Video& from);
  void MergeFrom(const Message_Video& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string instancefolder = 3;
  inline bool has_instancefolder() const;
  inline void clear_instancefolder();
  static const int kInstancefolderFieldNumber = 3;
  inline const ::std::string& instancefolder() const;
  inline void set_instancefolder(const ::std::string& value);
  inline void set_instancefolder(const char* value);
  inline void set_instancefolder(const char* value, size_t size);
  inline ::std::string* mutable_instancefolder();
  inline ::std::string* release_instancefolder();
  inline void set_allocated_instancefolder(::std::string* instancefolder);

  // @@protoc_insertion_point(class_scope:motion.Message.Video)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_instancefolder();
  inline void clear_has_instancefolder();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* path_;
  ::std::string* name_;
  ::std::string* instancefolder_;
  friend void  protobuf_AddDesc_motion_2eproto();
  friend void protobuf_AssignDesc_motion_2eproto();
  friend void protobuf_ShutdownFile_motion_2eproto();

  void InitAsDefaultInstance();
  static Message_Video* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Message_MotionDevice MotionDevice;
  typedef Message_MotionUser MotionUser;
  typedef Message_MotionCamera MotionCamera;
  typedef Message_MotionTrack MotionTrack;
  typedef Message_MotionRec MotionRec;
  typedef Message_MotionCron MotionCron;
  typedef Message_MotionMonth MotionMonth;
  typedef Message_MotionDay MotionDay;
  typedef Message_Instance Instance;
  typedef Message_Image Image;
  typedef Message_Crop Crop;
  typedef Message_Video Video;

  typedef Message_ResponseType ResponseType;
  static const ResponseType LOGIN_SUCCESSFUL = Message_ResponseType_LOGIN_SUCCESSFUL;
  static const ResponseType LOGIN_FAILED = Message_ResponseType_LOGIN_FAILED;
  static const ResponseType ERROR_INVALID_USERNAME = Message_ResponseType_ERROR_INVALID_USERNAME;
  static const ResponseType ERROR_INVALID_PASSWORD = Message_ResponseType_ERROR_INVALID_PASSWORD;
  static const ResponseType ERROR_LOGIN_FAILIURE = Message_ResponseType_ERROR_LOGIN_FAILIURE;
  static const ResponseType ERROR_TIMEOUT = Message_ResponseType_ERROR_TIMEOUT;
  static inline bool ResponseType_IsValid(int value) {
    return Message_ResponseType_IsValid(value);
  }
  static const ResponseType ResponseType_MIN =
    Message_ResponseType_ResponseType_MIN;
  static const ResponseType ResponseType_MAX =
    Message_ResponseType_ResponseType_MAX;
  static const int ResponseType_ARRAYSIZE =
    Message_ResponseType_ResponseType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResponseType_descriptor() {
    return Message_ResponseType_descriptor();
  }
  static inline const ::std::string& ResponseType_Name(ResponseType value) {
    return Message_ResponseType_Name(value);
  }
  static inline bool ResponseType_Parse(const ::std::string& name,
      ResponseType* value) {
    return Message_ResponseType_Parse(name, value);
  }

  typedef Message_ActionType ActionType;
  static const ActionType ENGAGE = Message_ActionType_ENGAGE;
  static const ActionType REC_START = Message_ActionType_REC_START;
  static const ActionType REC_RUNNING = Message_ActionType_REC_RUNNING;
  static const ActionType REC_STOP = Message_ActionType_REC_STOP;
  static const ActionType UNENGAGE = Message_ActionType_UNENGAGE;
  static const ActionType GET_TIME = Message_ActionType_GET_TIME;
  static const ActionType SET_TIME = Message_ActionType_SET_TIME;
  static const ActionType TIME_SET = Message_ActionType_TIME_SET;
  static const ActionType STRM_START = Message_ActionType_STRM_START;
  static const ActionType STRM_STOP = Message_ActionType_STRM_STOP;
  static const ActionType TAKE_PICTURE = Message_ActionType_TAKE_PICTURE;
  static const ActionType DISSCONNECT = Message_ActionType_DISSCONNECT;
  static const ActionType REFRESH = Message_ActionType_REFRESH;
  static const ActionType GET_XML = Message_ActionType_GET_XML;
  static const ActionType GET_IMAGE = Message_ActionType_GET_IMAGE;
  static const ActionType GET_VIDEO = Message_ActionType_GET_VIDEO;
  static const ActionType SAVE = Message_ActionType_SAVE;
  static const ActionType OPEN = Message_ActionType_OPEN;
  static const ActionType UPDATE = Message_ActionType_UPDATE;
  static const ActionType SAVE_OK = Message_ActionType_SAVE_OK;
  static const ActionType UPDATE_OK = Message_ActionType_UPDATE_OK;
  static const ActionType GET_MAT = Message_ActionType_GET_MAT;
  static const ActionType RESPONSE_OK = Message_ActionType_RESPONSE_OK;
  static const ActionType RESPONSE_NEXT = Message_ActionType_RESPONSE_NEXT;
  static const ActionType RESPONSE_END = Message_ActionType_RESPONSE_END;
  static const ActionType RESPONSE_FINISH = Message_ActionType_RESPONSE_FINISH;
  static const ActionType REC_HAS_CHANGES = Message_ActionType_REC_HAS_CHANGES;
  static const ActionType REC_HAS_INSTANCE = Message_ActionType_REC_HAS_INSTANCE;
  static const ActionType PROTO_HAS_FILE = Message_ActionType_PROTO_HAS_FILE;
  static const ActionType PROTO_NO_FILE = Message_ActionType_PROTO_NO_FILE;
  static const ActionType SERVER_INFO = Message_ActionType_SERVER_INFO;
  static const ActionType SERVER_INFO_OK = Message_ActionType_SERVER_INFO_OK;
  static inline bool ActionType_IsValid(int value) {
    return Message_ActionType_IsValid(value);
  }
  static const ActionType ActionType_MIN =
    Message_ActionType_ActionType_MIN;
  static const ActionType ActionType_MAX =
    Message_ActionType_ActionType_MAX;
  static const int ActionType_ARRAYSIZE =
    Message_ActionType_ActionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ActionType_descriptor() {
    return Message_ActionType_descriptor();
  }
  static inline const ::std::string& ActionType_Name(ActionType value) {
    return Message_ActionType_Name(value);
  }
  static inline bool ActionType_Parse(const ::std::string& name,
      ActionType* value) {
    return Message_ActionType_Parse(name, value);
  }

  typedef Message_SocketType SocketType;
  static const SocketType SOCKET_PROTO_TOSTRING = Message_SocketType_SOCKET_PROTO_TOSTRING;
  static const SocketType SOCKET_PROTO_TOARRAY = Message_SocketType_SOCKET_PROTO_TOARRAY;
  static const SocketType SOCKET_PLAIN_TEXT = Message_SocketType_SOCKET_PLAIN_TEXT;
  static const SocketType SPLITTED_MESSAGE = Message_SocketType_SPLITTED_MESSAGE;
  static const SocketType SINGLE_MESSAGE = Message_SocketType_SINGLE_MESSAGE;
  static const SocketType SOCKET_BUFFER_NANO_SIZE = Message_SocketType_SOCKET_BUFFER_NANO_SIZE;
  static const SocketType SOCKET_BUFFER_MINI_SIZE = Message_SocketType_SOCKET_BUFFER_MINI_SIZE;
  static const SocketType SOCKET_BUFFER_MICRO_SIZE = Message_SocketType_SOCKET_BUFFER_MICRO_SIZE;
  static const SocketType SOCKET_BUFFER_SMALL_SIZE = Message_SocketType_SOCKET_BUFFER_SMALL_SIZE;
  static const SocketType SOCKET_BUFFER_REGULAR_SIZE = Message_SocketType_SOCKET_BUFFER_REGULAR_SIZE;
  static const SocketType SOCKET_BUFFER_MEDIUM_SIZE = Message_SocketType_SOCKET_BUFFER_MEDIUM_SIZE;
  static const SocketType SOCKET_BUFFER_BIG_SIZE = Message_SocketType_SOCKET_BUFFER_BIG_SIZE;
  static const SocketType TCP_ECHO_PORT = Message_SocketType_TCP_ECHO_PORT;
  static const SocketType TCP_STREAMING_PORT = Message_SocketType_TCP_STREAMING_PORT;
  static const SocketType UDP_PORT = Message_SocketType_UDP_PORT;
  static const SocketType TCP_MSG_PORT = Message_SocketType_TCP_MSG_PORT;
  static inline bool SocketType_IsValid(int value) {
    return Message_SocketType_IsValid(value);
  }
  static const SocketType SocketType_MIN =
    Message_SocketType_SocketType_MIN;
  static const SocketType SocketType_MAX =
    Message_SocketType_SocketType_MAX;
  static const int SocketType_ARRAYSIZE =
    Message_SocketType_SocketType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SocketType_descriptor() {
    return Message_SocketType_descriptor();
  }
  static inline const ::std::string& SocketType_Name(SocketType value) {
    return Message_SocketType_Name(value);
  }
  static inline bool SocketType_Parse(const ::std::string& name,
      SocketType* value) {
    return Message_SocketType_Parse(name, value);
  }

  typedef Message_ProcessType ProcessType;
  static const ProcessType PROCESS_PEOPLE_COUNT = Message_ProcessType_PROCESS_PEOPLE_COUNT;
  static const ProcessType PROCESS_FACE_DETECT = Message_ProcessType_PROCESS_FACE_DETECT;
  static const ProcessType PROCESS_WALK_DIRECTION = Message_ProcessType_PROCESS_WALK_DIRECTION;
  static inline bool ProcessType_IsValid(int value) {
    return Message_ProcessType_IsValid(value);
  }
  static const ProcessType ProcessType_MIN =
    Message_ProcessType_ProcessType_MIN;
  static const ProcessType ProcessType_MAX =
    Message_ProcessType_ProcessType_MAX;
  static const int ProcessType_ARRAYSIZE =
    Message_ProcessType_ProcessType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProcessType_descriptor() {
    return Message_ProcessType_descriptor();
  }
  static inline const ::std::string& ProcessType_Name(ProcessType value) {
    return Message_ProcessType_Name(value);
  }
  static inline bool ProcessType_Parse(const ::std::string& name,
      ProcessType* value) {
    return Message_ProcessType_Parse(name, value);
  }

  typedef Message_ServiceType ServiceType;
  static const ServiceType SERVICE_FREE_ACCOUNT = Message_ServiceType_SERVICE_FREE_ACCOUNT;
  static const ServiceType SERVICE_PAID_ACCOUNT = Message_ServiceType_SERVICE_PAID_ACCOUNT;
  static inline bool ServiceType_IsValid(int value) {
    return Message_ServiceType_IsValid(value);
  }
  static const ServiceType ServiceType_MIN =
    Message_ServiceType_ServiceType_MIN;
  static const ServiceType ServiceType_MAX =
    Message_ServiceType_ServiceType_MAX;
  static const int ServiceType_ARRAYSIZE =
    Message_ServiceType_ServiceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ServiceType_descriptor() {
    return Message_ServiceType_descriptor();
  }
  static inline const ::std::string& ServiceType_Name(ServiceType value) {
    return Message_ServiceType_Name(value);
  }
  static inline bool ServiceType_Parse(const ::std::string& name,
      ServiceType* value) {
    return Message_ServiceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional int32 activecam = 1;
  inline bool has_activecam() const;
  inline void clear_activecam();
  static const int kActivecamFieldNumber = 1;
  inline ::google::protobuf::int32 activecam() const;
  inline void set_activecam(::google::protobuf::int32 value);

  // required .motion.Message.ActionType type = 2 [default = ENGAGE];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::motion::Message_ActionType type() const;
  inline void set_type(::motion::Message_ActionType value);

  // repeated .motion.Message.MotionUser motionuser = 3;
  inline int motionuser_size() const;
  inline void clear_motionuser();
  static const int kMotionuserFieldNumber = 3;
  inline const ::motion::Message_MotionUser& motionuser(int index) const;
  inline ::motion::Message_MotionUser* mutable_motionuser(int index);
  inline ::motion::Message_MotionUser* add_motionuser();
  inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionUser >&
      motionuser() const;
  inline ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionUser >*
      mutable_motionuser();

  // repeated .motion.Message.MotionCamera motioncamera = 4;
  inline int motioncamera_size() const;
  inline void clear_motioncamera();
  static const int kMotioncameraFieldNumber = 4;
  inline const ::motion::Message_MotionCamera& motioncamera(int index) const;
  inline ::motion::Message_MotionCamera* mutable_motioncamera(int index);
  inline ::motion::Message_MotionCamera* add_motioncamera();
  inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionCamera >&
      motioncamera() const;
  inline ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionCamera >*
      mutable_motioncamera();

  // repeated .motion.Message.MotionDevice motiondevice = 5;
  inline int motiondevice_size() const;
  inline void clear_motiondevice();
  static const int kMotiondeviceFieldNumber = 5;
  inline const ::motion::Message_MotionDevice& motiondevice(int index) const;
  inline ::motion::Message_MotionDevice* mutable_motiondevice(int index);
  inline ::motion::Message_MotionDevice* add_motiondevice();
  inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionDevice >&
      motiondevice() const;
  inline ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionDevice >*
      mutable_motiondevice();

  // optional string time = 6;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 6;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // optional bytes data = 7;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 7;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional int32 data_amount = 8;
  inline bool has_data_amount() const;
  inline void clear_data_amount();
  static const int kDataAmountFieldNumber = 8;
  inline ::google::protobuf::int32 data_amount() const;
  inline void set_data_amount(::google::protobuf::int32 value);

  // optional int32 data_total = 9;
  inline bool has_data_total() const;
  inline void clear_data_total();
  static const int kDataTotalFieldNumber = 9;
  inline ::google::protobuf::int32 data_total() const;
  inline void set_data_total(::google::protobuf::int32 value);

  // optional string serverip = 10;
  inline bool has_serverip() const;
  inline void clear_serverip();
  static const int kServeripFieldNumber = 10;
  inline const ::std::string& serverip() const;
  inline void set_serverip(const ::std::string& value);
  inline void set_serverip(const char* value);
  inline void set_serverip(const char* value, size_t size);
  inline ::std::string* mutable_serverip();
  inline ::std::string* release_serverip();
  inline void set_allocated_serverip(::std::string* serverip);

  // optional string clientip = 11;
  inline bool has_clientip() const;
  inline void clear_clientip();
  static const int kClientipFieldNumber = 11;
  inline const ::std::string& clientip() const;
  inline void set_clientip(const ::std::string& value);
  inline void set_clientip(const char* value);
  inline void set_clientip(const char* value, size_t size);
  inline ::std::string* mutable_clientip();
  inline ::std::string* release_clientip();
  inline void set_allocated_clientip(::std::string* clientip);

  // optional string devicestarttime = 12;
  inline bool has_devicestarttime() const;
  inline void clear_devicestarttime();
  static const int kDevicestarttimeFieldNumber = 12;
  inline const ::std::string& devicestarttime() const;
  inline void set_devicestarttime(const ::std::string& value);
  inline void set_devicestarttime(const char* value);
  inline void set_devicestarttime(const char* value, size_t size);
  inline ::std::string* mutable_devicestarttime();
  inline ::std::string* release_devicestarttime();
  inline void set_allocated_devicestarttime(::std::string* devicestarttime);

  // optional string currmonth = 13;
  inline bool has_currmonth() const;
  inline void clear_currmonth();
  static const int kCurrmonthFieldNumber = 13;
  inline const ::std::string& currmonth() const;
  inline void set_currmonth(const ::std::string& value);
  inline void set_currmonth(const char* value);
  inline void set_currmonth(const char* value, size_t size);
  inline ::std::string* mutable_currmonth();
  inline ::std::string* release_currmonth();
  inline void set_allocated_currmonth(::std::string* currmonth);

  // optional string currday = 14;
  inline bool has_currday() const;
  inline void clear_currday();
  static const int kCurrdayFieldNumber = 14;
  inline const ::std::string& currday() const;
  inline void set_currday(const ::std::string& value);
  inline void set_currday(const char* value);
  inline void set_currday(const char* value, size_t size);
  inline ::std::string* mutable_currday();
  inline ::std::string* release_currday();
  inline void set_allocated_currday(::std::string* currday);

  // optional string currdaytitle = 15;
  inline bool has_currdaytitle() const;
  inline void clear_currdaytitle();
  static const int kCurrdaytitleFieldNumber = 15;
  inline const ::std::string& currdaytitle() const;
  inline void set_currdaytitle(const ::std::string& value);
  inline void set_currdaytitle(const char* value);
  inline void set_currdaytitle(const char* value, size_t size);
  inline ::std::string* mutable_currdaytitle();
  inline ::std::string* release_currdaytitle();
  inline void set_allocated_currdaytitle(::std::string* currdaytitle);

  // optional int32 currcam = 16;
  inline bool has_currcam() const;
  inline void clear_currcam();
  static const int kCurrcamFieldNumber = 16;
  inline ::google::protobuf::int32 currcam() const;
  inline void set_currcam(::google::protobuf::int32 value);

  // optional int32 packagesize = 17;
  inline bool has_packagesize() const;
  inline void clear_packagesize();
  static const int kPackagesizeFieldNumber = 17;
  inline ::google::protobuf::int32 packagesize() const;
  inline void set_packagesize(::google::protobuf::int32 value);

  // optional string imagefilepath = 18;
  inline bool has_imagefilepath() const;
  inline void clear_imagefilepath();
  static const int kImagefilepathFieldNumber = 18;
  inline const ::std::string& imagefilepath() const;
  inline void set_imagefilepath(const ::std::string& value);
  inline void set_imagefilepath(const char* value);
  inline void set_imagefilepath(const char* value, size_t size);
  inline ::std::string* mutable_imagefilepath();
  inline ::std::string* release_imagefilepath();
  inline void set_allocated_imagefilepath(::std::string* imagefilepath);

  // optional string videofilepath = 19;
  inline bool has_videofilepath() const;
  inline void clear_videofilepath();
  static const int kVideofilepathFieldNumber = 19;
  inline const ::std::string& videofilepath() const;
  inline void set_videofilepath(const ::std::string& value);
  inline void set_videofilepath(const char* value);
  inline void set_videofilepath(const char* value, size_t size);
  inline ::std::string* mutable_videofilepath();
  inline ::std::string* release_videofilepath();
  inline void set_allocated_videofilepath(::std::string* videofilepath);

  // optional string recname = 20;
  inline bool has_recname() const;
  inline void clear_recname();
  static const int kRecnameFieldNumber = 20;
  inline const ::std::string& recname() const;
  inline void set_recname(const ::std::string& value);
  inline void set_recname(const char* value);
  inline void set_recname(const char* value, size_t size);
  inline ::std::string* mutable_recname();
  inline ::std::string* release_recname();
  inline void set_allocated_recname(::std::string* recname);

  // optional int32 activecamnum = 21;
  inline bool has_activecamnum() const;
  inline void clear_activecamnum();
  static const int kActivecamnumFieldNumber = 21;
  inline ::google::protobuf::int32 activecamnum() const;
  inline void set_activecamnum(::google::protobuf::int32 value);

  // optional bool includethubmnails = 22;
  inline bool has_includethubmnails() const;
  inline void clear_includethubmnails();
  static const int kIncludethubmnailsFieldNumber = 22;
  inline bool includethubmnails() const;
  inline void set_includethubmnails(bool value);

  // @@protoc_insertion_point(class_scope:motion.Message)
 private:
  inline void set_has_activecam();
  inline void clear_has_activecam();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_data_amount();
  inline void clear_has_data_amount();
  inline void set_has_data_total();
  inline void clear_has_data_total();
  inline void set_has_serverip();
  inline void clear_has_serverip();
  inline void set_has_clientip();
  inline void clear_has_clientip();
  inline void set_has_devicestarttime();
  inline void clear_has_devicestarttime();
  inline void set_has_currmonth();
  inline void clear_has_currmonth();
  inline void set_has_currday();
  inline void clear_has_currday();
  inline void set_has_currdaytitle();
  inline void clear_has_currdaytitle();
  inline void set_has_currcam();
  inline void clear_has_currcam();
  inline void set_has_packagesize();
  inline void clear_has_packagesize();
  inline void set_has_imagefilepath();
  inline void clear_has_imagefilepath();
  inline void set_has_videofilepath();
  inline void clear_has_videofilepath();
  inline void set_has_recname();
  inline void clear_has_recname();
  inline void set_has_activecamnum();
  inline void clear_has_activecamnum();
  inline void set_has_includethubmnails();
  inline void clear_has_includethubmnails();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 activecam_;
  int type_;
  ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionUser > motionuser_;
  ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionCamera > motioncamera_;
  ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionDevice > motiondevice_;
  ::std::string* time_;
  ::std::string* data_;
  ::google::protobuf::int32 data_amount_;
  ::google::protobuf::int32 data_total_;
  ::std::string* serverip_;
  ::std::string* clientip_;
  ::std::string* devicestarttime_;
  ::std::string* currmonth_;
  ::std::string* currday_;
  ::std::string* currdaytitle_;
  ::google::protobuf::int32 currcam_;
  ::google::protobuf::int32 packagesize_;
  ::std::string* imagefilepath_;
  ::std::string* videofilepath_;
  ::std::string* recname_;
  ::google::protobuf::int32 activecamnum_;
  bool includethubmnails_;
  friend void  protobuf_AddDesc_motion_2eproto();
  friend void protobuf_AssignDesc_motion_2eproto();
  friend void protobuf_ShutdownFile_motion_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// ===================================================================


// ===================================================================

// Message_MotionDevice

// optional string ipnumber = 1;
inline bool Message_MotionDevice::has_ipnumber() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message_MotionDevice::set_has_ipnumber() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message_MotionDevice::clear_has_ipnumber() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message_MotionDevice::clear_ipnumber() {
  if (ipnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ipnumber_->clear();
  }
  clear_has_ipnumber();
}
inline const ::std::string& Message_MotionDevice::ipnumber() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionDevice.ipnumber)
  return *ipnumber_;
}
inline void Message_MotionDevice::set_ipnumber(const ::std::string& value) {
  set_has_ipnumber();
  if (ipnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ipnumber_ = new ::std::string;
  }
  ipnumber_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionDevice.ipnumber)
}
inline void Message_MotionDevice::set_ipnumber(const char* value) {
  set_has_ipnumber();
  if (ipnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ipnumber_ = new ::std::string;
  }
  ipnumber_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionDevice.ipnumber)
}
inline void Message_MotionDevice::set_ipnumber(const char* value, size_t size) {
  set_has_ipnumber();
  if (ipnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ipnumber_ = new ::std::string;
  }
  ipnumber_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionDevice.ipnumber)
}
inline ::std::string* Message_MotionDevice::mutable_ipnumber() {
  set_has_ipnumber();
  if (ipnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ipnumber_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionDevice.ipnumber)
  return ipnumber_;
}
inline ::std::string* Message_MotionDevice::release_ipnumber() {
  clear_has_ipnumber();
  if (ipnumber_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ipnumber_;
    ipnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionDevice::set_allocated_ipnumber(::std::string* ipnumber) {
  if (ipnumber_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ipnumber_;
  }
  if (ipnumber) {
    set_has_ipnumber();
    ipnumber_ = ipnumber;
  } else {
    clear_has_ipnumber();
    ipnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionDevice.ipnumber)
}

// optional string ippublic = 2;
inline bool Message_MotionDevice::has_ippublic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message_MotionDevice::set_has_ippublic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message_MotionDevice::clear_has_ippublic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message_MotionDevice::clear_ippublic() {
  if (ippublic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ippublic_->clear();
  }
  clear_has_ippublic();
}
inline const ::std::string& Message_MotionDevice::ippublic() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionDevice.ippublic)
  return *ippublic_;
}
inline void Message_MotionDevice::set_ippublic(const ::std::string& value) {
  set_has_ippublic();
  if (ippublic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ippublic_ = new ::std::string;
  }
  ippublic_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionDevice.ippublic)
}
inline void Message_MotionDevice::set_ippublic(const char* value) {
  set_has_ippublic();
  if (ippublic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ippublic_ = new ::std::string;
  }
  ippublic_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionDevice.ippublic)
}
inline void Message_MotionDevice::set_ippublic(const char* value, size_t size) {
  set_has_ippublic();
  if (ippublic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ippublic_ = new ::std::string;
  }
  ippublic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionDevice.ippublic)
}
inline ::std::string* Message_MotionDevice::mutable_ippublic() {
  set_has_ippublic();
  if (ippublic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ippublic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionDevice.ippublic)
  return ippublic_;
}
inline ::std::string* Message_MotionDevice::release_ippublic() {
  clear_has_ippublic();
  if (ippublic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ippublic_;
    ippublic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionDevice::set_allocated_ippublic(::std::string* ippublic) {
  if (ippublic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ippublic_;
  }
  if (ippublic) {
    set_has_ippublic();
    ippublic_ = ippublic;
  } else {
    clear_has_ippublic();
    ippublic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionDevice.ippublic)
}

// optional string macaddress = 3;
inline bool Message_MotionDevice::has_macaddress() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message_MotionDevice::set_has_macaddress() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message_MotionDevice::clear_has_macaddress() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message_MotionDevice::clear_macaddress() {
  if (macaddress_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    macaddress_->clear();
  }
  clear_has_macaddress();
}
inline const ::std::string& Message_MotionDevice::macaddress() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionDevice.macaddress)
  return *macaddress_;
}
inline void Message_MotionDevice::set_macaddress(const ::std::string& value) {
  set_has_macaddress();
  if (macaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    macaddress_ = new ::std::string;
  }
  macaddress_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionDevice.macaddress)
}
inline void Message_MotionDevice::set_macaddress(const char* value) {
  set_has_macaddress();
  if (macaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    macaddress_ = new ::std::string;
  }
  macaddress_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionDevice.macaddress)
}
inline void Message_MotionDevice::set_macaddress(const char* value, size_t size) {
  set_has_macaddress();
  if (macaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    macaddress_ = new ::std::string;
  }
  macaddress_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionDevice.macaddress)
}
inline ::std::string* Message_MotionDevice::mutable_macaddress() {
  set_has_macaddress();
  if (macaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    macaddress_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionDevice.macaddress)
  return macaddress_;
}
inline ::std::string* Message_MotionDevice::release_macaddress() {
  clear_has_macaddress();
  if (macaddress_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = macaddress_;
    macaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionDevice::set_allocated_macaddress(::std::string* macaddress) {
  if (macaddress_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete macaddress_;
  }
  if (macaddress) {
    set_has_macaddress();
    macaddress_ = macaddress;
  } else {
    clear_has_macaddress();
    macaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionDevice.macaddress)
}

// optional string hostname = 4;
inline bool Message_MotionDevice::has_hostname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message_MotionDevice::set_has_hostname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message_MotionDevice::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message_MotionDevice::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& Message_MotionDevice::hostname() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionDevice.hostname)
  return *hostname_;
}
inline void Message_MotionDevice::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionDevice.hostname)
}
inline void Message_MotionDevice::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionDevice.hostname)
}
inline void Message_MotionDevice::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionDevice.hostname)
}
inline ::std::string* Message_MotionDevice::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hostname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionDevice.hostname)
  return hostname_;
}
inline ::std::string* Message_MotionDevice::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionDevice::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionDevice.hostname)
}

// optional string city = 5;
inline bool Message_MotionDevice::has_city() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message_MotionDevice::set_has_city() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message_MotionDevice::clear_has_city() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message_MotionDevice::clear_city() {
  if (city_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& Message_MotionDevice::city() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionDevice.city)
  return *city_;
}
inline void Message_MotionDevice::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  city_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionDevice.city)
}
inline void Message_MotionDevice::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  city_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionDevice.city)
}
inline void Message_MotionDevice::set_city(const char* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionDevice.city)
}
inline ::std::string* Message_MotionDevice::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    city_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionDevice.city)
  return city_;
}
inline ::std::string* Message_MotionDevice::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionDevice::set_allocated_city(::std::string* city) {
  if (city_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete city_;
  }
  if (city) {
    set_has_city();
    city_ = city;
  } else {
    clear_has_city();
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionDevice.city)
}

// optional string country = 6;
inline bool Message_MotionDevice::has_country() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Message_MotionDevice::set_has_country() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Message_MotionDevice::clear_has_country() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Message_MotionDevice::clear_country() {
  if (country_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_->clear();
  }
  clear_has_country();
}
inline const ::std::string& Message_MotionDevice::country() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionDevice.country)
  return *country_;
}
inline void Message_MotionDevice::set_country(const ::std::string& value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  country_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionDevice.country)
}
inline void Message_MotionDevice::set_country(const char* value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  country_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionDevice.country)
}
inline void Message_MotionDevice::set_country(const char* value, size_t size) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  country_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionDevice.country)
}
inline ::std::string* Message_MotionDevice::mutable_country() {
  set_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    country_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionDevice.country)
  return country_;
}
inline ::std::string* Message_MotionDevice::release_country() {
  clear_has_country();
  if (country_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = country_;
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionDevice::set_allocated_country(::std::string* country) {
  if (country_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete country_;
  }
  if (country) {
    set_has_country();
    country_ = country;
  } else {
    clear_has_country();
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionDevice.country)
}

// optional string location = 7;
inline bool Message_MotionDevice::has_location() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Message_MotionDevice::set_has_location() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Message_MotionDevice::clear_has_location() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Message_MotionDevice::clear_location() {
  if (location_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& Message_MotionDevice::location() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionDevice.location)
  return *location_;
}
inline void Message_MotionDevice::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    location_ = new ::std::string;
  }
  location_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionDevice.location)
}
inline void Message_MotionDevice::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    location_ = new ::std::string;
  }
  location_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionDevice.location)
}
inline void Message_MotionDevice::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionDevice.location)
}
inline ::std::string* Message_MotionDevice::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    location_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionDevice.location)
  return location_;
}
inline ::std::string* Message_MotionDevice::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionDevice::set_allocated_location(::std::string* location) {
  if (location_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete location_;
  }
  if (location) {
    set_has_location();
    location_ = location;
  } else {
    clear_has_location();
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionDevice.location)
}

// optional string network_provider = 8;
inline bool Message_MotionDevice::has_network_provider() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Message_MotionDevice::set_has_network_provider() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Message_MotionDevice::clear_has_network_provider() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Message_MotionDevice::clear_network_provider() {
  if (network_provider_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    network_provider_->clear();
  }
  clear_has_network_provider();
}
inline const ::std::string& Message_MotionDevice::network_provider() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionDevice.network_provider)
  return *network_provider_;
}
inline void Message_MotionDevice::set_network_provider(const ::std::string& value) {
  set_has_network_provider();
  if (network_provider_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    network_provider_ = new ::std::string;
  }
  network_provider_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionDevice.network_provider)
}
inline void Message_MotionDevice::set_network_provider(const char* value) {
  set_has_network_provider();
  if (network_provider_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    network_provider_ = new ::std::string;
  }
  network_provider_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionDevice.network_provider)
}
inline void Message_MotionDevice::set_network_provider(const char* value, size_t size) {
  set_has_network_provider();
  if (network_provider_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    network_provider_ = new ::std::string;
  }
  network_provider_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionDevice.network_provider)
}
inline ::std::string* Message_MotionDevice::mutable_network_provider() {
  set_has_network_provider();
  if (network_provider_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    network_provider_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionDevice.network_provider)
  return network_provider_;
}
inline ::std::string* Message_MotionDevice::release_network_provider() {
  clear_has_network_provider();
  if (network_provider_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = network_provider_;
    network_provider_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionDevice::set_allocated_network_provider(::std::string* network_provider) {
  if (network_provider_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete network_provider_;
  }
  if (network_provider) {
    set_has_network_provider();
    network_provider_ = network_provider;
  } else {
    clear_has_network_provider();
    network_provider_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionDevice.network_provider)
}

// optional string uptime = 9;
inline bool Message_MotionDevice::has_uptime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Message_MotionDevice::set_has_uptime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Message_MotionDevice::clear_has_uptime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Message_MotionDevice::clear_uptime() {
  if (uptime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uptime_->clear();
  }
  clear_has_uptime();
}
inline const ::std::string& Message_MotionDevice::uptime() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionDevice.uptime)
  return *uptime_;
}
inline void Message_MotionDevice::set_uptime(const ::std::string& value) {
  set_has_uptime();
  if (uptime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uptime_ = new ::std::string;
  }
  uptime_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionDevice.uptime)
}
inline void Message_MotionDevice::set_uptime(const char* value) {
  set_has_uptime();
  if (uptime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uptime_ = new ::std::string;
  }
  uptime_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionDevice.uptime)
}
inline void Message_MotionDevice::set_uptime(const char* value, size_t size) {
  set_has_uptime();
  if (uptime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uptime_ = new ::std::string;
  }
  uptime_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionDevice.uptime)
}
inline ::std::string* Message_MotionDevice::mutable_uptime() {
  set_has_uptime();
  if (uptime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uptime_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionDevice.uptime)
  return uptime_;
}
inline ::std::string* Message_MotionDevice::release_uptime() {
  clear_has_uptime();
  if (uptime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = uptime_;
    uptime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionDevice::set_allocated_uptime(::std::string* uptime) {
  if (uptime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete uptime_;
  }
  if (uptime) {
    set_has_uptime();
    uptime_ = uptime;
  } else {
    clear_has_uptime();
    uptime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionDevice.uptime)
}

// optional string starttime = 10;
inline bool Message_MotionDevice::has_starttime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Message_MotionDevice::set_has_starttime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Message_MotionDevice::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Message_MotionDevice::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& Message_MotionDevice::starttime() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionDevice.starttime)
  return *starttime_;
}
inline void Message_MotionDevice::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionDevice.starttime)
}
inline void Message_MotionDevice::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionDevice.starttime)
}
inline void Message_MotionDevice::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionDevice.starttime)
}
inline ::std::string* Message_MotionDevice::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    starttime_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionDevice.starttime)
  return starttime_;
}
inline ::std::string* Message_MotionDevice::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionDevice::set_allocated_starttime(::std::string* starttime) {
  if (starttime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete starttime_;
  }
  if (starttime) {
    set_has_starttime();
    starttime_ = starttime;
  } else {
    clear_has_starttime();
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionDevice.starttime)
}

// optional int32 db_local = 11;
inline bool Message_MotionDevice::has_db_local() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Message_MotionDevice::set_has_db_local() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Message_MotionDevice::clear_has_db_local() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Message_MotionDevice::clear_db_local() {
  db_local_ = 0;
  clear_has_db_local();
}
inline ::google::protobuf::int32 Message_MotionDevice::db_local() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionDevice.db_local)
  return db_local_;
}
inline void Message_MotionDevice::set_db_local(::google::protobuf::int32 value) {
  set_has_db_local();
  db_local_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionDevice.db_local)
}

// optional string model = 12;
inline bool Message_MotionDevice::has_model() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Message_MotionDevice::set_has_model() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Message_MotionDevice::clear_has_model() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Message_MotionDevice::clear_model() {
  if (model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_->clear();
  }
  clear_has_model();
}
inline const ::std::string& Message_MotionDevice::model() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionDevice.model)
  return *model_;
}
inline void Message_MotionDevice::set_model(const ::std::string& value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionDevice.model)
}
inline void Message_MotionDevice::set_model(const char* value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionDevice.model)
}
inline void Message_MotionDevice::set_model(const char* value, size_t size) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionDevice.model)
}
inline ::std::string* Message_MotionDevice::mutable_model() {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionDevice.model)
  return model_;
}
inline ::std::string* Message_MotionDevice::release_model() {
  clear_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = model_;
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionDevice::set_allocated_model(::std::string* model) {
  if (model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete model_;
  }
  if (model) {
    set_has_model();
    model_ = model;
  } else {
    clear_has_model();
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionDevice.model)
}

// optional string hardware = 13;
inline bool Message_MotionDevice::has_hardware() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Message_MotionDevice::set_has_hardware() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Message_MotionDevice::clear_has_hardware() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Message_MotionDevice::clear_hardware() {
  if (hardware_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hardware_->clear();
  }
  clear_has_hardware();
}
inline const ::std::string& Message_MotionDevice::hardware() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionDevice.hardware)
  return *hardware_;
}
inline void Message_MotionDevice::set_hardware(const ::std::string& value) {
  set_has_hardware();
  if (hardware_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hardware_ = new ::std::string;
  }
  hardware_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionDevice.hardware)
}
inline void Message_MotionDevice::set_hardware(const char* value) {
  set_has_hardware();
  if (hardware_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hardware_ = new ::std::string;
  }
  hardware_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionDevice.hardware)
}
inline void Message_MotionDevice::set_hardware(const char* value, size_t size) {
  set_has_hardware();
  if (hardware_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hardware_ = new ::std::string;
  }
  hardware_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionDevice.hardware)
}
inline ::std::string* Message_MotionDevice::mutable_hardware() {
  set_has_hardware();
  if (hardware_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hardware_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionDevice.hardware)
  return hardware_;
}
inline ::std::string* Message_MotionDevice::release_hardware() {
  clear_has_hardware();
  if (hardware_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hardware_;
    hardware_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionDevice::set_allocated_hardware(::std::string* hardware) {
  if (hardware_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hardware_;
  }
  if (hardware) {
    set_has_hardware();
    hardware_ = hardware;
  } else {
    clear_has_hardware();
    hardware_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionDevice.hardware)
}

// optional string serial = 14;
inline bool Message_MotionDevice::has_serial() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Message_MotionDevice::set_has_serial() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Message_MotionDevice::clear_has_serial() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Message_MotionDevice::clear_serial() {
  if (serial_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serial_->clear();
  }
  clear_has_serial();
}
inline const ::std::string& Message_MotionDevice::serial() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionDevice.serial)
  return *serial_;
}
inline void Message_MotionDevice::set_serial(const ::std::string& value) {
  set_has_serial();
  if (serial_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serial_ = new ::std::string;
  }
  serial_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionDevice.serial)
}
inline void Message_MotionDevice::set_serial(const char* value) {
  set_has_serial();
  if (serial_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serial_ = new ::std::string;
  }
  serial_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionDevice.serial)
}
inline void Message_MotionDevice::set_serial(const char* value, size_t size) {
  set_has_serial();
  if (serial_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serial_ = new ::std::string;
  }
  serial_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionDevice.serial)
}
inline ::std::string* Message_MotionDevice::mutable_serial() {
  set_has_serial();
  if (serial_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serial_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionDevice.serial)
  return serial_;
}
inline ::std::string* Message_MotionDevice::release_serial() {
  clear_has_serial();
  if (serial_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = serial_;
    serial_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionDevice::set_allocated_serial(::std::string* serial) {
  if (serial_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete serial_;
  }
  if (serial) {
    set_has_serial();
    serial_ = serial;
  } else {
    clear_has_serial();
    serial_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionDevice.serial)
}

// optional string revision = 15;
inline bool Message_MotionDevice::has_revision() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Message_MotionDevice::set_has_revision() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Message_MotionDevice::clear_has_revision() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Message_MotionDevice::clear_revision() {
  if (revision_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revision_->clear();
  }
  clear_has_revision();
}
inline const ::std::string& Message_MotionDevice::revision() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionDevice.revision)
  return *revision_;
}
inline void Message_MotionDevice::set_revision(const ::std::string& value) {
  set_has_revision();
  if (revision_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revision_ = new ::std::string;
  }
  revision_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionDevice.revision)
}
inline void Message_MotionDevice::set_revision(const char* value) {
  set_has_revision();
  if (revision_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revision_ = new ::std::string;
  }
  revision_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionDevice.revision)
}
inline void Message_MotionDevice::set_revision(const char* value, size_t size) {
  set_has_revision();
  if (revision_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revision_ = new ::std::string;
  }
  revision_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionDevice.revision)
}
inline ::std::string* Message_MotionDevice::mutable_revision() {
  set_has_revision();
  if (revision_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    revision_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionDevice.revision)
  return revision_;
}
inline ::std::string* Message_MotionDevice::release_revision() {
  clear_has_revision();
  if (revision_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = revision_;
    revision_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionDevice::set_allocated_revision(::std::string* revision) {
  if (revision_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete revision_;
  }
  if (revision) {
    set_has_revision();
    revision_ = revision;
  } else {
    clear_has_revision();
    revision_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionDevice.revision)
}

// optional int32 disktotal = 16;
inline bool Message_MotionDevice::has_disktotal() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Message_MotionDevice::set_has_disktotal() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Message_MotionDevice::clear_has_disktotal() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Message_MotionDevice::clear_disktotal() {
  disktotal_ = 0;
  clear_has_disktotal();
}
inline ::google::protobuf::int32 Message_MotionDevice::disktotal() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionDevice.disktotal)
  return disktotal_;
}
inline void Message_MotionDevice::set_disktotal(::google::protobuf::int32 value) {
  set_has_disktotal();
  disktotal_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionDevice.disktotal)
}

// optional int32 diskused = 17;
inline bool Message_MotionDevice::has_diskused() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Message_MotionDevice::set_has_diskused() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Message_MotionDevice::clear_has_diskused() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Message_MotionDevice::clear_diskused() {
  diskused_ = 0;
  clear_has_diskused();
}
inline ::google::protobuf::int32 Message_MotionDevice::diskused() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionDevice.diskused)
  return diskused_;
}
inline void Message_MotionDevice::set_diskused(::google::protobuf::int32 value) {
  set_has_diskused();
  diskused_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionDevice.diskused)
}

// optional int32 diskavailable = 18;
inline bool Message_MotionDevice::has_diskavailable() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Message_MotionDevice::set_has_diskavailable() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Message_MotionDevice::clear_has_diskavailable() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Message_MotionDevice::clear_diskavailable() {
  diskavailable_ = 0;
  clear_has_diskavailable();
}
inline ::google::protobuf::int32 Message_MotionDevice::diskavailable() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionDevice.diskavailable)
  return diskavailable_;
}
inline void Message_MotionDevice::set_diskavailable(::google::protobuf::int32 value) {
  set_has_diskavailable();
  diskavailable_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionDevice.diskavailable)
}

// optional int32 disk_percentage_used = 19;
inline bool Message_MotionDevice::has_disk_percentage_used() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Message_MotionDevice::set_has_disk_percentage_used() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Message_MotionDevice::clear_has_disk_percentage_used() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Message_MotionDevice::clear_disk_percentage_used() {
  disk_percentage_used_ = 0;
  clear_has_disk_percentage_used();
}
inline ::google::protobuf::int32 Message_MotionDevice::disk_percentage_used() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionDevice.disk_percentage_used)
  return disk_percentage_used_;
}
inline void Message_MotionDevice::set_disk_percentage_used(::google::protobuf::int32 value) {
  set_has_disk_percentage_used();
  disk_percentage_used_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionDevice.disk_percentage_used)
}

// optional int32 temperature = 20;
inline bool Message_MotionDevice::has_temperature() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Message_MotionDevice::set_has_temperature() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Message_MotionDevice::clear_has_temperature() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Message_MotionDevice::clear_temperature() {
  temperature_ = 0;
  clear_has_temperature();
}
inline ::google::protobuf::int32 Message_MotionDevice::temperature() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionDevice.temperature)
  return temperature_;
}
inline void Message_MotionDevice::set_temperature(::google::protobuf::int32 value) {
  set_has_temperature();
  temperature_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionDevice.temperature)
}

// -------------------------------------------------------------------

// Message_MotionUser

// optional int32 clientnumber = 1;
inline bool Message_MotionUser::has_clientnumber() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message_MotionUser::set_has_clientnumber() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message_MotionUser::clear_has_clientnumber() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message_MotionUser::clear_clientnumber() {
  clientnumber_ = 0;
  clear_has_clientnumber();
}
inline ::google::protobuf::int32 Message_MotionUser::clientnumber() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionUser.clientnumber)
  return clientnumber_;
}
inline void Message_MotionUser::set_clientnumber(::google::protobuf::int32 value) {
  set_has_clientnumber();
  clientnumber_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionUser.clientnumber)
}

// optional string wpuser = 2;
inline bool Message_MotionUser::has_wpuser() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message_MotionUser::set_has_wpuser() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message_MotionUser::clear_has_wpuser() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message_MotionUser::clear_wpuser() {
  if (wpuser_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    wpuser_->clear();
  }
  clear_has_wpuser();
}
inline const ::std::string& Message_MotionUser::wpuser() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionUser.wpuser)
  return *wpuser_;
}
inline void Message_MotionUser::set_wpuser(const ::std::string& value) {
  set_has_wpuser();
  if (wpuser_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    wpuser_ = new ::std::string;
  }
  wpuser_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionUser.wpuser)
}
inline void Message_MotionUser::set_wpuser(const char* value) {
  set_has_wpuser();
  if (wpuser_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    wpuser_ = new ::std::string;
  }
  wpuser_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionUser.wpuser)
}
inline void Message_MotionUser::set_wpuser(const char* value, size_t size) {
  set_has_wpuser();
  if (wpuser_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    wpuser_ = new ::std::string;
  }
  wpuser_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionUser.wpuser)
}
inline ::std::string* Message_MotionUser::mutable_wpuser() {
  set_has_wpuser();
  if (wpuser_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    wpuser_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionUser.wpuser)
  return wpuser_;
}
inline ::std::string* Message_MotionUser::release_wpuser() {
  clear_has_wpuser();
  if (wpuser_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = wpuser_;
    wpuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionUser::set_allocated_wpuser(::std::string* wpuser) {
  if (wpuser_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete wpuser_;
  }
  if (wpuser) {
    set_has_wpuser();
    wpuser_ = wpuser;
  } else {
    clear_has_wpuser();
    wpuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionUser.wpuser)
}

// optional string wppassword = 3;
inline bool Message_MotionUser::has_wppassword() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message_MotionUser::set_has_wppassword() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message_MotionUser::clear_has_wppassword() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message_MotionUser::clear_wppassword() {
  if (wppassword_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    wppassword_->clear();
  }
  clear_has_wppassword();
}
inline const ::std::string& Message_MotionUser::wppassword() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionUser.wppassword)
  return *wppassword_;
}
inline void Message_MotionUser::set_wppassword(const ::std::string& value) {
  set_has_wppassword();
  if (wppassword_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    wppassword_ = new ::std::string;
  }
  wppassword_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionUser.wppassword)
}
inline void Message_MotionUser::set_wppassword(const char* value) {
  set_has_wppassword();
  if (wppassword_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    wppassword_ = new ::std::string;
  }
  wppassword_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionUser.wppassword)
}
inline void Message_MotionUser::set_wppassword(const char* value, size_t size) {
  set_has_wppassword();
  if (wppassword_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    wppassword_ = new ::std::string;
  }
  wppassword_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionUser.wppassword)
}
inline ::std::string* Message_MotionUser::mutable_wppassword() {
  set_has_wppassword();
  if (wppassword_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    wppassword_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionUser.wppassword)
  return wppassword_;
}
inline ::std::string* Message_MotionUser::release_wppassword() {
  clear_has_wppassword();
  if (wppassword_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = wppassword_;
    wppassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionUser::set_allocated_wppassword(::std::string* wppassword) {
  if (wppassword_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete wppassword_;
  }
  if (wppassword) {
    set_has_wppassword();
    wppassword_ = wppassword;
  } else {
    clear_has_wppassword();
    wppassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionUser.wppassword)
}

// optional string wpserverurl = 4;
inline bool Message_MotionUser::has_wpserverurl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message_MotionUser::set_has_wpserverurl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message_MotionUser::clear_has_wpserverurl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message_MotionUser::clear_wpserverurl() {
  if (wpserverurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    wpserverurl_->clear();
  }
  clear_has_wpserverurl();
}
inline const ::std::string& Message_MotionUser::wpserverurl() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionUser.wpserverurl)
  return *wpserverurl_;
}
inline void Message_MotionUser::set_wpserverurl(const ::std::string& value) {
  set_has_wpserverurl();
  if (wpserverurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    wpserverurl_ = new ::std::string;
  }
  wpserverurl_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionUser.wpserverurl)
}
inline void Message_MotionUser::set_wpserverurl(const char* value) {
  set_has_wpserverurl();
  if (wpserverurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    wpserverurl_ = new ::std::string;
  }
  wpserverurl_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionUser.wpserverurl)
}
inline void Message_MotionUser::set_wpserverurl(const char* value, size_t size) {
  set_has_wpserverurl();
  if (wpserverurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    wpserverurl_ = new ::std::string;
  }
  wpserverurl_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionUser.wpserverurl)
}
inline ::std::string* Message_MotionUser::mutable_wpserverurl() {
  set_has_wpserverurl();
  if (wpserverurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    wpserverurl_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionUser.wpserverurl)
  return wpserverurl_;
}
inline ::std::string* Message_MotionUser::release_wpserverurl() {
  clear_has_wpserverurl();
  if (wpserverurl_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = wpserverurl_;
    wpserverurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionUser::set_allocated_wpserverurl(::std::string* wpserverurl) {
  if (wpserverurl_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete wpserverurl_;
  }
  if (wpserverurl) {
    set_has_wpserverurl();
    wpserverurl_ = wpserverurl;
  } else {
    clear_has_wpserverurl();
    wpserverurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionUser.wpserverurl)
}

// optional int32 wpuserid = 5;
inline bool Message_MotionUser::has_wpuserid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message_MotionUser::set_has_wpuserid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message_MotionUser::clear_has_wpuserid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message_MotionUser::clear_wpuserid() {
  wpuserid_ = 0;
  clear_has_wpuserid();
}
inline ::google::protobuf::int32 Message_MotionUser::wpuserid() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionUser.wpuserid)
  return wpuserid_;
}
inline void Message_MotionUser::set_wpuserid(::google::protobuf::int32 value) {
  set_has_wpuserid();
  wpuserid_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionUser.wpuserid)
}

// optional int32 wpclientid = 6;
inline bool Message_MotionUser::has_wpclientid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Message_MotionUser::set_has_wpclientid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Message_MotionUser::clear_has_wpclientid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Message_MotionUser::clear_wpclientid() {
  wpclientid_ = 0;
  clear_has_wpclientid();
}
inline ::google::protobuf::int32 Message_MotionUser::wpclientid() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionUser.wpclientid)
  return wpclientid_;
}
inline void Message_MotionUser::set_wpclientid(::google::protobuf::int32 value) {
  set_has_wpclientid();
  wpclientid_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionUser.wpclientid)
}

// optional int32 wpclientmediaid = 7;
inline bool Message_MotionUser::has_wpclientmediaid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Message_MotionUser::set_has_wpclientmediaid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Message_MotionUser::clear_has_wpclientmediaid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Message_MotionUser::clear_wpclientmediaid() {
  wpclientmediaid_ = 0;
  clear_has_wpclientmediaid();
}
inline ::google::protobuf::int32 Message_MotionUser::wpclientmediaid() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionUser.wpclientmediaid)
  return wpclientmediaid_;
}
inline void Message_MotionUser::set_wpclientmediaid(::google::protobuf::int32 value) {
  set_has_wpclientmediaid();
  wpclientmediaid_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionUser.wpclientmediaid)
}

// optional string pfobjectid = 8;
inline bool Message_MotionUser::has_pfobjectid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Message_MotionUser::set_has_pfobjectid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Message_MotionUser::clear_has_pfobjectid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Message_MotionUser::clear_pfobjectid() {
  if (pfobjectid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pfobjectid_->clear();
  }
  clear_has_pfobjectid();
}
inline const ::std::string& Message_MotionUser::pfobjectid() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionUser.pfobjectid)
  return *pfobjectid_;
}
inline void Message_MotionUser::set_pfobjectid(const ::std::string& value) {
  set_has_pfobjectid();
  if (pfobjectid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pfobjectid_ = new ::std::string;
  }
  pfobjectid_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionUser.pfobjectid)
}
inline void Message_MotionUser::set_pfobjectid(const char* value) {
  set_has_pfobjectid();
  if (pfobjectid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pfobjectid_ = new ::std::string;
  }
  pfobjectid_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionUser.pfobjectid)
}
inline void Message_MotionUser::set_pfobjectid(const char* value, size_t size) {
  set_has_pfobjectid();
  if (pfobjectid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pfobjectid_ = new ::std::string;
  }
  pfobjectid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionUser.pfobjectid)
}
inline ::std::string* Message_MotionUser::mutable_pfobjectid() {
  set_has_pfobjectid();
  if (pfobjectid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pfobjectid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionUser.pfobjectid)
  return pfobjectid_;
}
inline ::std::string* Message_MotionUser::release_pfobjectid() {
  clear_has_pfobjectid();
  if (pfobjectid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pfobjectid_;
    pfobjectid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionUser::set_allocated_pfobjectid(::std::string* pfobjectid) {
  if (pfobjectid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pfobjectid_;
  }
  if (pfobjectid) {
    set_has_pfobjectid();
    pfobjectid_ = pfobjectid;
  } else {
    clear_has_pfobjectid();
    pfobjectid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionUser.pfobjectid)
}

// optional string username = 9;
inline bool Message_MotionUser::has_username() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Message_MotionUser::set_has_username() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Message_MotionUser::clear_has_username() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Message_MotionUser::clear_username() {
  if (username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& Message_MotionUser::username() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionUser.username)
  return *username_;
}
inline void Message_MotionUser::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  username_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionUser.username)
}
inline void Message_MotionUser::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  username_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionUser.username)
}
inline void Message_MotionUser::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionUser.username)
}
inline ::std::string* Message_MotionUser::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    username_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionUser.username)
  return username_;
}
inline ::std::string* Message_MotionUser::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionUser::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionUser.username)
}

// optional string email = 10;
inline bool Message_MotionUser::has_email() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Message_MotionUser::set_has_email() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Message_MotionUser::clear_has_email() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Message_MotionUser::clear_email() {
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& Message_MotionUser::email() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionUser.email)
  return *email_;
}
inline void Message_MotionUser::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionUser.email)
}
inline void Message_MotionUser::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionUser.email)
}
inline void Message_MotionUser::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionUser.email)
}
inline ::std::string* Message_MotionUser::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    email_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionUser.email)
  return email_;
}
inline ::std::string* Message_MotionUser::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionUser::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionUser.email)
}

// optional string firstname = 11;
inline bool Message_MotionUser::has_firstname() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Message_MotionUser::set_has_firstname() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Message_MotionUser::clear_has_firstname() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Message_MotionUser::clear_firstname() {
  if (firstname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_->clear();
  }
  clear_has_firstname();
}
inline const ::std::string& Message_MotionUser::firstname() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionUser.firstname)
  return *firstname_;
}
inline void Message_MotionUser::set_firstname(const ::std::string& value) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionUser.firstname)
}
inline void Message_MotionUser::set_firstname(const char* value) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionUser.firstname)
}
inline void Message_MotionUser::set_firstname(const char* value, size_t size) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionUser.firstname)
}
inline ::std::string* Message_MotionUser::mutable_firstname() {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firstname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionUser.firstname)
  return firstname_;
}
inline ::std::string* Message_MotionUser::release_firstname() {
  clear_has_firstname();
  if (firstname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = firstname_;
    firstname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionUser::set_allocated_firstname(::std::string* firstname) {
  if (firstname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete firstname_;
  }
  if (firstname) {
    set_has_firstname();
    firstname_ = firstname;
  } else {
    clear_has_firstname();
    firstname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionUser.firstname)
}

// optional string lastname = 12;
inline bool Message_MotionUser::has_lastname() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Message_MotionUser::set_has_lastname() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Message_MotionUser::clear_has_lastname() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Message_MotionUser::clear_lastname() {
  if (lastname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastname_->clear();
  }
  clear_has_lastname();
}
inline const ::std::string& Message_MotionUser::lastname() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionUser.lastname)
  return *lastname_;
}
inline void Message_MotionUser::set_lastname(const ::std::string& value) {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastname_ = new ::std::string;
  }
  lastname_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionUser.lastname)
}
inline void Message_MotionUser::set_lastname(const char* value) {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastname_ = new ::std::string;
  }
  lastname_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionUser.lastname)
}
inline void Message_MotionUser::set_lastname(const char* value, size_t size) {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastname_ = new ::std::string;
  }
  lastname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionUser.lastname)
}
inline ::std::string* Message_MotionUser::mutable_lastname() {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionUser.lastname)
  return lastname_;
}
inline ::std::string* Message_MotionUser::release_lastname() {
  clear_has_lastname();
  if (lastname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = lastname_;
    lastname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionUser::set_allocated_lastname(::std::string* lastname) {
  if (lastname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete lastname_;
  }
  if (lastname) {
    set_has_lastname();
    lastname_ = lastname;
  } else {
    clear_has_lastname();
    lastname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionUser.lastname)
}

// optional string location = 13;
inline bool Message_MotionUser::has_location() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Message_MotionUser::set_has_location() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Message_MotionUser::clear_has_location() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Message_MotionUser::clear_location() {
  if (location_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& Message_MotionUser::location() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionUser.location)
  return *location_;
}
inline void Message_MotionUser::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    location_ = new ::std::string;
  }
  location_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionUser.location)
}
inline void Message_MotionUser::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    location_ = new ::std::string;
  }
  location_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionUser.location)
}
inline void Message_MotionUser::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionUser.location)
}
inline ::std::string* Message_MotionUser::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    location_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionUser.location)
  return location_;
}
inline ::std::string* Message_MotionUser::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionUser::set_allocated_location(::std::string* location) {
  if (location_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete location_;
  }
  if (location) {
    set_has_location();
    location_ = location;
  } else {
    clear_has_location();
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionUser.location)
}

// optional string uiidinstallation = 14;
inline bool Message_MotionUser::has_uiidinstallation() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Message_MotionUser::set_has_uiidinstallation() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Message_MotionUser::clear_has_uiidinstallation() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Message_MotionUser::clear_uiidinstallation() {
  if (uiidinstallation_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uiidinstallation_->clear();
  }
  clear_has_uiidinstallation();
}
inline const ::std::string& Message_MotionUser::uiidinstallation() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionUser.uiidinstallation)
  return *uiidinstallation_;
}
inline void Message_MotionUser::set_uiidinstallation(const ::std::string& value) {
  set_has_uiidinstallation();
  if (uiidinstallation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uiidinstallation_ = new ::std::string;
  }
  uiidinstallation_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionUser.uiidinstallation)
}
inline void Message_MotionUser::set_uiidinstallation(const char* value) {
  set_has_uiidinstallation();
  if (uiidinstallation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uiidinstallation_ = new ::std::string;
  }
  uiidinstallation_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionUser.uiidinstallation)
}
inline void Message_MotionUser::set_uiidinstallation(const char* value, size_t size) {
  set_has_uiidinstallation();
  if (uiidinstallation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uiidinstallation_ = new ::std::string;
  }
  uiidinstallation_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionUser.uiidinstallation)
}
inline ::std::string* Message_MotionUser::mutable_uiidinstallation() {
  set_has_uiidinstallation();
  if (uiidinstallation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uiidinstallation_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionUser.uiidinstallation)
  return uiidinstallation_;
}
inline ::std::string* Message_MotionUser::release_uiidinstallation() {
  clear_has_uiidinstallation();
  if (uiidinstallation_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = uiidinstallation_;
    uiidinstallation_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionUser::set_allocated_uiidinstallation(::std::string* uiidinstallation) {
  if (uiidinstallation_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete uiidinstallation_;
  }
  if (uiidinstallation) {
    set_has_uiidinstallation();
    uiidinstallation_ = uiidinstallation;
  } else {
    clear_has_uiidinstallation();
    uiidinstallation_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionUser.uiidinstallation)
}

// optional int32 service_type = 15;
inline bool Message_MotionUser::has_service_type() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Message_MotionUser::set_has_service_type() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Message_MotionUser::clear_has_service_type() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Message_MotionUser::clear_service_type() {
  service_type_ = 0;
  clear_has_service_type();
}
inline ::google::protobuf::int32 Message_MotionUser::service_type() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionUser.service_type)
  return service_type_;
}
inline void Message_MotionUser::set_service_type(::google::protobuf::int32 value) {
  set_has_service_type();
  service_type_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionUser.service_type)
}

// -------------------------------------------------------------------

// Message_MotionCamera

// repeated .motion.Message.MotionMonth motionmonth = 1;
inline int Message_MotionCamera::motionmonth_size() const {
  return motionmonth_.size();
}
inline void Message_MotionCamera::clear_motionmonth() {
  motionmonth_.Clear();
}
inline const ::motion::Message_MotionMonth& Message_MotionCamera::motionmonth(int index) const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionCamera.motionmonth)
  return motionmonth_.Get(index);
}
inline ::motion::Message_MotionMonth* Message_MotionCamera::mutable_motionmonth(int index) {
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionCamera.motionmonth)
  return motionmonth_.Mutable(index);
}
inline ::motion::Message_MotionMonth* Message_MotionCamera::add_motionmonth() {
  // @@protoc_insertion_point(field_add:motion.Message.MotionCamera.motionmonth)
  return motionmonth_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionMonth >&
Message_MotionCamera::motionmonth() const {
  // @@protoc_insertion_point(field_list:motion.Message.MotionCamera.motionmonth)
  return motionmonth_;
}
inline ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionMonth >*
Message_MotionCamera::mutable_motionmonth() {
  // @@protoc_insertion_point(field_mutable_list:motion.Message.MotionCamera.motionmonth)
  return &motionmonth_;
}

// repeated .motion.Message.MotionRec motionrec = 2;
inline int Message_MotionCamera::motionrec_size() const {
  return motionrec_.size();
}
inline void Message_MotionCamera::clear_motionrec() {
  motionrec_.Clear();
}
inline const ::motion::Message_MotionRec& Message_MotionCamera::motionrec(int index) const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionCamera.motionrec)
  return motionrec_.Get(index);
}
inline ::motion::Message_MotionRec* Message_MotionCamera::mutable_motionrec(int index) {
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionCamera.motionrec)
  return motionrec_.Mutable(index);
}
inline ::motion::Message_MotionRec* Message_MotionCamera::add_motionrec() {
  // @@protoc_insertion_point(field_add:motion.Message.MotionCamera.motionrec)
  return motionrec_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionRec >&
Message_MotionCamera::motionrec() const {
  // @@protoc_insertion_point(field_list:motion.Message.MotionCamera.motionrec)
  return motionrec_;
}
inline ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionRec >*
Message_MotionCamera::mutable_motionrec() {
  // @@protoc_insertion_point(field_mutable_list:motion.Message.MotionCamera.motionrec)
  return &motionrec_;
}

// optional int32 cameraid = 3 [default = 0];
inline bool Message_MotionCamera::has_cameraid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message_MotionCamera::set_has_cameraid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message_MotionCamera::clear_has_cameraid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message_MotionCamera::clear_cameraid() {
  cameraid_ = 0;
  clear_has_cameraid();
}
inline ::google::protobuf::int32 Message_MotionCamera::cameraid() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionCamera.cameraid)
  return cameraid_;
}
inline void Message_MotionCamera::set_cameraid(::google::protobuf::int32 value) {
  set_has_cameraid();
  cameraid_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionCamera.cameraid)
}

// optional int32 cameranumber = 4;
inline bool Message_MotionCamera::has_cameranumber() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message_MotionCamera::set_has_cameranumber() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message_MotionCamera::clear_has_cameranumber() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message_MotionCamera::clear_cameranumber() {
  cameranumber_ = 0;
  clear_has_cameranumber();
}
inline ::google::protobuf::int32 Message_MotionCamera::cameranumber() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionCamera.cameranumber)
  return cameranumber_;
}
inline void Message_MotionCamera::set_cameranumber(::google::protobuf::int32 value) {
  set_has_cameranumber();
  cameranumber_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionCamera.cameranumber)
}

// optional string cameraname = 5;
inline bool Message_MotionCamera::has_cameraname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message_MotionCamera::set_has_cameraname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message_MotionCamera::clear_has_cameraname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message_MotionCamera::clear_cameraname() {
  if (cameraname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cameraname_->clear();
  }
  clear_has_cameraname();
}
inline const ::std::string& Message_MotionCamera::cameraname() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionCamera.cameraname)
  return *cameraname_;
}
inline void Message_MotionCamera::set_cameraname(const ::std::string& value) {
  set_has_cameraname();
  if (cameraname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cameraname_ = new ::std::string;
  }
  cameraname_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionCamera.cameraname)
}
inline void Message_MotionCamera::set_cameraname(const char* value) {
  set_has_cameraname();
  if (cameraname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cameraname_ = new ::std::string;
  }
  cameraname_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionCamera.cameraname)
}
inline void Message_MotionCamera::set_cameraname(const char* value, size_t size) {
  set_has_cameraname();
  if (cameraname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cameraname_ = new ::std::string;
  }
  cameraname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionCamera.cameraname)
}
inline ::std::string* Message_MotionCamera::mutable_cameraname() {
  set_has_cameraname();
  if (cameraname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cameraname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionCamera.cameraname)
  return cameraname_;
}
inline ::std::string* Message_MotionCamera::release_cameraname() {
  clear_has_cameraname();
  if (cameraname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cameraname_;
    cameraname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionCamera::set_allocated_cameraname(::std::string* cameraname) {
  if (cameraname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cameraname_;
  }
  if (cameraname) {
    set_has_cameraname();
    cameraname_ = cameraname;
  } else {
    clear_has_cameraname();
    cameraname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionCamera.cameraname)
}

// optional bool hasrecjob = 6;
inline bool Message_MotionCamera::has_hasrecjob() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Message_MotionCamera::set_has_hasrecjob() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Message_MotionCamera::clear_has_hasrecjob() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Message_MotionCamera::clear_hasrecjob() {
  hasrecjob_ = false;
  clear_has_hasrecjob();
}
inline bool Message_MotionCamera::hasrecjob() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionCamera.hasrecjob)
  return hasrecjob_;
}
inline void Message_MotionCamera::set_hasrecjob(bool value) {
  set_has_hasrecjob();
  hasrecjob_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionCamera.hasrecjob)
}

// optional bool recognizing = 7;
inline bool Message_MotionCamera::has_recognizing() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Message_MotionCamera::set_has_recognizing() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Message_MotionCamera::clear_has_recognizing() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Message_MotionCamera::clear_recognizing() {
  recognizing_ = false;
  clear_has_recognizing();
}
inline bool Message_MotionCamera::recognizing() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionCamera.recognizing)
  return recognizing_;
}
inline void Message_MotionCamera::set_recognizing(bool value) {
  set_has_recognizing();
  recognizing_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionCamera.recognizing)
}

// optional bool recognizing_flag = 8;
inline bool Message_MotionCamera::has_recognizing_flag() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Message_MotionCamera::set_has_recognizing_flag() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Message_MotionCamera::clear_has_recognizing_flag() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Message_MotionCamera::clear_recognizing_flag() {
  recognizing_flag_ = false;
  clear_has_recognizing_flag();
}
inline bool Message_MotionCamera::recognizing_flag() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionCamera.recognizing_flag)
  return recognizing_flag_;
}
inline void Message_MotionCamera::set_recognizing_flag(bool value) {
  set_has_recognizing_flag();
  recognizing_flag_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionCamera.recognizing_flag)
}

// optional int32 db_idcamera = 9;
inline bool Message_MotionCamera::has_db_idcamera() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Message_MotionCamera::set_has_db_idcamera() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Message_MotionCamera::clear_has_db_idcamera() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Message_MotionCamera::clear_db_idcamera() {
  db_idcamera_ = 0;
  clear_has_db_idcamera();
}
inline ::google::protobuf::int32 Message_MotionCamera::db_idcamera() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionCamera.db_idcamera)
  return db_idcamera_;
}
inline void Message_MotionCamera::set_db_idcamera(::google::protobuf::int32 value) {
  set_has_db_idcamera();
  db_idcamera_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionCamera.db_idcamera)
}

// optional int32 db_idrec = 10;
inline bool Message_MotionCamera::has_db_idrec() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Message_MotionCamera::set_has_db_idrec() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Message_MotionCamera::clear_has_db_idrec() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Message_MotionCamera::clear_db_idrec() {
  db_idrec_ = 0;
  clear_has_db_idrec();
}
inline ::google::protobuf::int32 Message_MotionCamera::db_idrec() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionCamera.db_idrec)
  return db_idrec_;
}
inline void Message_MotionCamera::set_db_idrec(::google::protobuf::int32 value) {
  set_has_db_idrec();
  db_idrec_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionCamera.db_idrec)
}

// optional bool fromdatabase = 11;
inline bool Message_MotionCamera::has_fromdatabase() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Message_MotionCamera::set_has_fromdatabase() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Message_MotionCamera::clear_has_fromdatabase() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Message_MotionCamera::clear_fromdatabase() {
  fromdatabase_ = false;
  clear_has_fromdatabase();
}
inline bool Message_MotionCamera::fromdatabase() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionCamera.fromdatabase)
  return fromdatabase_;
}
inline void Message_MotionCamera::set_fromdatabase(bool value) {
  set_has_fromdatabase();
  fromdatabase_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionCamera.fromdatabase)
}

// repeated .motion.Message.MotionTrack motiontrack = 12;
inline int Message_MotionCamera::motiontrack_size() const {
  return motiontrack_.size();
}
inline void Message_MotionCamera::clear_motiontrack() {
  motiontrack_.Clear();
}
inline const ::motion::Message_MotionTrack& Message_MotionCamera::motiontrack(int index) const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionCamera.motiontrack)
  return motiontrack_.Get(index);
}
inline ::motion::Message_MotionTrack* Message_MotionCamera::mutable_motiontrack(int index) {
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionCamera.motiontrack)
  return motiontrack_.Mutable(index);
}
inline ::motion::Message_MotionTrack* Message_MotionCamera::add_motiontrack() {
  // @@protoc_insertion_point(field_add:motion.Message.MotionCamera.motiontrack)
  return motiontrack_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionTrack >&
Message_MotionCamera::motiontrack() const {
  // @@protoc_insertion_point(field_list:motion.Message.MotionCamera.motiontrack)
  return motiontrack_;
}
inline ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionTrack >*
Message_MotionCamera::mutable_motiontrack() {
  // @@protoc_insertion_point(field_mutable_list:motion.Message.MotionCamera.motiontrack)
  return &motiontrack_;
}

// optional int32 activemat = 13;
inline bool Message_MotionCamera::has_activemat() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Message_MotionCamera::set_has_activemat() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Message_MotionCamera::clear_has_activemat() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Message_MotionCamera::clear_activemat() {
  activemat_ = 0;
  clear_has_activemat();
}
inline ::google::protobuf::int32 Message_MotionCamera::activemat() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionCamera.activemat)
  return activemat_;
}
inline void Message_MotionCamera::set_activemat(::google::protobuf::int32 value) {
  set_has_activemat();
  activemat_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionCamera.activemat)
}

// optional int32 matcols = 14;
inline bool Message_MotionCamera::has_matcols() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Message_MotionCamera::set_has_matcols() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Message_MotionCamera::clear_has_matcols() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Message_MotionCamera::clear_matcols() {
  matcols_ = 0;
  clear_has_matcols();
}
inline ::google::protobuf::int32 Message_MotionCamera::matcols() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionCamera.matcols)
  return matcols_;
}
inline void Message_MotionCamera::set_matcols(::google::protobuf::int32 value) {
  set_has_matcols();
  matcols_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionCamera.matcols)
}

// optional int32 matrows = 15;
inline bool Message_MotionCamera::has_matrows() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Message_MotionCamera::set_has_matrows() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Message_MotionCamera::clear_has_matrows() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Message_MotionCamera::clear_matrows() {
  matrows_ = 0;
  clear_has_matrows();
}
inline ::google::protobuf::int32 Message_MotionCamera::matrows() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionCamera.matrows)
  return matrows_;
}
inline void Message_MotionCamera::set_matrows(::google::protobuf::int32 value) {
  set_has_matrows();
  matrows_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionCamera.matrows)
}

// optional int32 matwidth = 16;
inline bool Message_MotionCamera::has_matwidth() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Message_MotionCamera::set_has_matwidth() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Message_MotionCamera::clear_has_matwidth() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Message_MotionCamera::clear_matwidth() {
  matwidth_ = 0;
  clear_has_matwidth();
}
inline ::google::protobuf::int32 Message_MotionCamera::matwidth() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionCamera.matwidth)
  return matwidth_;
}
inline void Message_MotionCamera::set_matwidth(::google::protobuf::int32 value) {
  set_has_matwidth();
  matwidth_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionCamera.matwidth)
}

// optional int32 matheight = 17;
inline bool Message_MotionCamera::has_matheight() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Message_MotionCamera::set_has_matheight() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Message_MotionCamera::clear_has_matheight() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Message_MotionCamera::clear_matheight() {
  matheight_ = 0;
  clear_has_matheight();
}
inline ::google::protobuf::int32 Message_MotionCamera::matheight() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionCamera.matheight)
  return matheight_;
}
inline void Message_MotionCamera::set_matheight(::google::protobuf::int32 value) {
  set_has_matheight();
  matheight_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionCamera.matheight)
}

// optional int32 db_idmat = 18;
inline bool Message_MotionCamera::has_db_idmat() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Message_MotionCamera::set_has_db_idmat() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Message_MotionCamera::clear_has_db_idmat() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Message_MotionCamera::clear_db_idmat() {
  db_idmat_ = 0;
  clear_has_db_idmat();
}
inline ::google::protobuf::int32 Message_MotionCamera::db_idmat() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionCamera.db_idmat)
  return db_idmat_;
}
inline void Message_MotionCamera::set_db_idmat(::google::protobuf::int32 value) {
  set_has_db_idmat();
  db_idmat_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionCamera.db_idmat)
}

// optional bytes tempdata = 19;
inline bool Message_MotionCamera::has_tempdata() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Message_MotionCamera::set_has_tempdata() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Message_MotionCamera::clear_has_tempdata() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Message_MotionCamera::clear_tempdata() {
  if (tempdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tempdata_->clear();
  }
  clear_has_tempdata();
}
inline const ::std::string& Message_MotionCamera::tempdata() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionCamera.tempdata)
  return *tempdata_;
}
inline void Message_MotionCamera::set_tempdata(const ::std::string& value) {
  set_has_tempdata();
  if (tempdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tempdata_ = new ::std::string;
  }
  tempdata_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionCamera.tempdata)
}
inline void Message_MotionCamera::set_tempdata(const char* value) {
  set_has_tempdata();
  if (tempdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tempdata_ = new ::std::string;
  }
  tempdata_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionCamera.tempdata)
}
inline void Message_MotionCamera::set_tempdata(const void* value, size_t size) {
  set_has_tempdata();
  if (tempdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tempdata_ = new ::std::string;
  }
  tempdata_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionCamera.tempdata)
}
inline ::std::string* Message_MotionCamera::mutable_tempdata() {
  set_has_tempdata();
  if (tempdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tempdata_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionCamera.tempdata)
  return tempdata_;
}
inline ::std::string* Message_MotionCamera::release_tempdata() {
  clear_has_tempdata();
  if (tempdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tempdata_;
    tempdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionCamera::set_allocated_tempdata(::std::string* tempdata) {
  if (tempdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tempdata_;
  }
  if (tempdata) {
    set_has_tempdata();
    tempdata_ = tempdata;
  } else {
    clear_has_tempdata();
    tempdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionCamera.tempdata)
}

// optional bytes thumbnail = 20;
inline bool Message_MotionCamera::has_thumbnail() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Message_MotionCamera::set_has_thumbnail() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Message_MotionCamera::clear_has_thumbnail() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Message_MotionCamera::clear_thumbnail() {
  if (thumbnail_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumbnail_->clear();
  }
  clear_has_thumbnail();
}
inline const ::std::string& Message_MotionCamera::thumbnail() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionCamera.thumbnail)
  return *thumbnail_;
}
inline void Message_MotionCamera::set_thumbnail(const ::std::string& value) {
  set_has_thumbnail();
  if (thumbnail_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumbnail_ = new ::std::string;
  }
  thumbnail_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionCamera.thumbnail)
}
inline void Message_MotionCamera::set_thumbnail(const char* value) {
  set_has_thumbnail();
  if (thumbnail_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumbnail_ = new ::std::string;
  }
  thumbnail_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionCamera.thumbnail)
}
inline void Message_MotionCamera::set_thumbnail(const void* value, size_t size) {
  set_has_thumbnail();
  if (thumbnail_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumbnail_ = new ::std::string;
  }
  thumbnail_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionCamera.thumbnail)
}
inline ::std::string* Message_MotionCamera::mutable_thumbnail() {
  set_has_thumbnail();
  if (thumbnail_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    thumbnail_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionCamera.thumbnail)
  return thumbnail_;
}
inline ::std::string* Message_MotionCamera::release_thumbnail() {
  clear_has_thumbnail();
  if (thumbnail_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = thumbnail_;
    thumbnail_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionCamera::set_allocated_thumbnail(::std::string* thumbnail) {
  if (thumbnail_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete thumbnail_;
  }
  if (thumbnail) {
    set_has_thumbnail();
    thumbnail_ = thumbnail;
  } else {
    clear_has_thumbnail();
    thumbnail_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionCamera.thumbnail)
}

// -------------------------------------------------------------------

// Message_MotionTrack

// optional int32 db_idinstance = 1;
inline bool Message_MotionTrack::has_db_idinstance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message_MotionTrack::set_has_db_idinstance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message_MotionTrack::clear_has_db_idinstance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message_MotionTrack::clear_db_idinstance() {
  db_idinstance_ = 0;
  clear_has_db_idinstance();
}
inline ::google::protobuf::int32 Message_MotionTrack::db_idinstance() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionTrack.db_idinstance)
  return db_idinstance_;
}
inline void Message_MotionTrack::set_db_idinstance(::google::protobuf::int32 value) {
  set_has_db_idinstance();
  db_idinstance_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionTrack.db_idinstance)
}

// -------------------------------------------------------------------

// Message_MotionRec

// optional string name = 1;
inline bool Message_MotionRec::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message_MotionRec::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message_MotionRec::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message_MotionRec::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Message_MotionRec::name() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.name)
  return *name_;
}
inline void Message_MotionRec::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.name)
}
inline void Message_MotionRec::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionRec.name)
}
inline void Message_MotionRec::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionRec.name)
}
inline ::std::string* Message_MotionRec::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionRec.name)
  return name_;
}
inline ::std::string* Message_MotionRec::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionRec::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionRec.name)
}

// optional int32 db_idrec = 2;
inline bool Message_MotionRec::has_db_idrec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message_MotionRec::set_has_db_idrec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message_MotionRec::clear_has_db_idrec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message_MotionRec::clear_db_idrec() {
  db_idrec_ = 0;
  clear_has_db_idrec();
}
inline ::google::protobuf::int32 Message_MotionRec::db_idrec() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.db_idrec)
  return db_idrec_;
}
inline void Message_MotionRec::set_db_idrec(::google::protobuf::int32 value) {
  set_has_db_idrec();
  db_idrec_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.db_idrec)
}

// optional string timestart = 3;
inline bool Message_MotionRec::has_timestart() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message_MotionRec::set_has_timestart() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message_MotionRec::clear_has_timestart() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message_MotionRec::clear_timestart() {
  if (timestart_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    timestart_->clear();
  }
  clear_has_timestart();
}
inline const ::std::string& Message_MotionRec::timestart() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.timestart)
  return *timestart_;
}
inline void Message_MotionRec::set_timestart(const ::std::string& value) {
  set_has_timestart();
  if (timestart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    timestart_ = new ::std::string;
  }
  timestart_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.timestart)
}
inline void Message_MotionRec::set_timestart(const char* value) {
  set_has_timestart();
  if (timestart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    timestart_ = new ::std::string;
  }
  timestart_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionRec.timestart)
}
inline void Message_MotionRec::set_timestart(const char* value, size_t size) {
  set_has_timestart();
  if (timestart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    timestart_ = new ::std::string;
  }
  timestart_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionRec.timestart)
}
inline ::std::string* Message_MotionRec::mutable_timestart() {
  set_has_timestart();
  if (timestart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    timestart_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionRec.timestart)
  return timestart_;
}
inline ::std::string* Message_MotionRec::release_timestart() {
  clear_has_timestart();
  if (timestart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = timestart_;
    timestart_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionRec::set_allocated_timestart(::std::string* timestart) {
  if (timestart_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete timestart_;
  }
  if (timestart) {
    set_has_timestart();
    timestart_ = timestart;
  } else {
    clear_has_timestart();
    timestart_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionRec.timestart)
}

// optional string timeend = 4;
inline bool Message_MotionRec::has_timeend() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message_MotionRec::set_has_timeend() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message_MotionRec::clear_has_timeend() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message_MotionRec::clear_timeend() {
  if (timeend_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    timeend_->clear();
  }
  clear_has_timeend();
}
inline const ::std::string& Message_MotionRec::timeend() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.timeend)
  return *timeend_;
}
inline void Message_MotionRec::set_timeend(const ::std::string& value) {
  set_has_timeend();
  if (timeend_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    timeend_ = new ::std::string;
  }
  timeend_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.timeend)
}
inline void Message_MotionRec::set_timeend(const char* value) {
  set_has_timeend();
  if (timeend_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    timeend_ = new ::std::string;
  }
  timeend_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionRec.timeend)
}
inline void Message_MotionRec::set_timeend(const char* value, size_t size) {
  set_has_timeend();
  if (timeend_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    timeend_ = new ::std::string;
  }
  timeend_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionRec.timeend)
}
inline ::std::string* Message_MotionRec::mutable_timeend() {
  set_has_timeend();
  if (timeend_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    timeend_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionRec.timeend)
  return timeend_;
}
inline ::std::string* Message_MotionRec::release_timeend() {
  clear_has_timeend();
  if (timeend_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = timeend_;
    timeend_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionRec::set_allocated_timeend(::std::string* timeend) {
  if (timeend_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete timeend_;
  }
  if (timeend) {
    set_has_timeend();
    timeend_ = timeend;
  } else {
    clear_has_timeend();
    timeend_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionRec.timeend)
}

// optional string recname = 5;
inline bool Message_MotionRec::has_recname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message_MotionRec::set_has_recname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message_MotionRec::clear_has_recname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message_MotionRec::clear_recname() {
  if (recname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recname_->clear();
  }
  clear_has_recname();
}
inline const ::std::string& Message_MotionRec::recname() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.recname)
  return *recname_;
}
inline void Message_MotionRec::set_recname(const ::std::string& value) {
  set_has_recname();
  if (recname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recname_ = new ::std::string;
  }
  recname_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.recname)
}
inline void Message_MotionRec::set_recname(const char* value) {
  set_has_recname();
  if (recname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recname_ = new ::std::string;
  }
  recname_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionRec.recname)
}
inline void Message_MotionRec::set_recname(const char* value, size_t size) {
  set_has_recname();
  if (recname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recname_ = new ::std::string;
  }
  recname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionRec.recname)
}
inline ::std::string* Message_MotionRec::mutable_recname() {
  set_has_recname();
  if (recname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionRec.recname)
  return recname_;
}
inline ::std::string* Message_MotionRec::release_recname() {
  clear_has_recname();
  if (recname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = recname_;
    recname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionRec::set_allocated_recname(::std::string* recname) {
  if (recname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete recname_;
  }
  if (recname) {
    set_has_recname();
    recname_ = recname;
  } else {
    clear_has_recname();
    recname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionRec.recname)
}

// optional string camerasince = 6;
inline bool Message_MotionRec::has_camerasince() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Message_MotionRec::set_has_camerasince() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Message_MotionRec::clear_has_camerasince() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Message_MotionRec::clear_camerasince() {
  if (camerasince_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camerasince_->clear();
  }
  clear_has_camerasince();
}
inline const ::std::string& Message_MotionRec::camerasince() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.camerasince)
  return *camerasince_;
}
inline void Message_MotionRec::set_camerasince(const ::std::string& value) {
  set_has_camerasince();
  if (camerasince_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camerasince_ = new ::std::string;
  }
  camerasince_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.camerasince)
}
inline void Message_MotionRec::set_camerasince(const char* value) {
  set_has_camerasince();
  if (camerasince_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camerasince_ = new ::std::string;
  }
  camerasince_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionRec.camerasince)
}
inline void Message_MotionRec::set_camerasince(const char* value, size_t size) {
  set_has_camerasince();
  if (camerasince_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camerasince_ = new ::std::string;
  }
  camerasince_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionRec.camerasince)
}
inline ::std::string* Message_MotionRec::mutable_camerasince() {
  set_has_camerasince();
  if (camerasince_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camerasince_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionRec.camerasince)
  return camerasince_;
}
inline ::std::string* Message_MotionRec::release_camerasince() {
  clear_has_camerasince();
  if (camerasince_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = camerasince_;
    camerasince_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionRec::set_allocated_camerasince(::std::string* camerasince) {
  if (camerasince_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete camerasince_;
  }
  if (camerasince) {
    set_has_camerasince();
    camerasince_ = camerasince;
  } else {
    clear_has_camerasince();
    camerasince_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionRec.camerasince)
}

// optional bool storeimage = 7;
inline bool Message_MotionRec::has_storeimage() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Message_MotionRec::set_has_storeimage() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Message_MotionRec::clear_has_storeimage() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Message_MotionRec::clear_storeimage() {
  storeimage_ = false;
  clear_has_storeimage();
}
inline bool Message_MotionRec::storeimage() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.storeimage)
  return storeimage_;
}
inline void Message_MotionRec::set_storeimage(bool value) {
  set_has_storeimage();
  storeimage_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.storeimage)
}

// optional bool storevideo = 8;
inline bool Message_MotionRec::has_storevideo() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Message_MotionRec::set_has_storevideo() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Message_MotionRec::clear_has_storevideo() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Message_MotionRec::clear_storevideo() {
  storevideo_ = false;
  clear_has_storevideo();
}
inline bool Message_MotionRec::storevideo() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.storevideo)
  return storevideo_;
}
inline void Message_MotionRec::set_storevideo(bool value) {
  set_has_storevideo();
  storevideo_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.storevideo)
}

// optional string codename = 9;
inline bool Message_MotionRec::has_codename() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Message_MotionRec::set_has_codename() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Message_MotionRec::clear_has_codename() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Message_MotionRec::clear_codename() {
  if (codename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    codename_->clear();
  }
  clear_has_codename();
}
inline const ::std::string& Message_MotionRec::codename() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.codename)
  return *codename_;
}
inline void Message_MotionRec::set_codename(const ::std::string& value) {
  set_has_codename();
  if (codename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    codename_ = new ::std::string;
  }
  codename_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.codename)
}
inline void Message_MotionRec::set_codename(const char* value) {
  set_has_codename();
  if (codename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    codename_ = new ::std::string;
  }
  codename_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionRec.codename)
}
inline void Message_MotionRec::set_codename(const char* value, size_t size) {
  set_has_codename();
  if (codename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    codename_ = new ::std::string;
  }
  codename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionRec.codename)
}
inline ::std::string* Message_MotionRec::mutable_codename() {
  set_has_codename();
  if (codename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    codename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionRec.codename)
  return codename_;
}
inline ::std::string* Message_MotionRec::release_codename() {
  clear_has_codename();
  if (codename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = codename_;
    codename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionRec::set_allocated_codename(::std::string* codename) {
  if (codename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete codename_;
  }
  if (codename) {
    set_has_codename();
    codename_ = codename;
  } else {
    clear_has_codename();
    codename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionRec.codename)
}

// optional bool hasregion = 10;
inline bool Message_MotionRec::has_hasregion() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Message_MotionRec::set_has_hasregion() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Message_MotionRec::clear_has_hasregion() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Message_MotionRec::clear_hasregion() {
  hasregion_ = false;
  clear_has_hasregion();
}
inline bool Message_MotionRec::hasregion() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.hasregion)
  return hasregion_;
}
inline void Message_MotionRec::set_hasregion(bool value) {
  set_has_hasregion();
  hasregion_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.hasregion)
}

// optional string coordinates = 11;
inline bool Message_MotionRec::has_coordinates() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Message_MotionRec::set_has_coordinates() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Message_MotionRec::clear_has_coordinates() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Message_MotionRec::clear_coordinates() {
  if (coordinates_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    coordinates_->clear();
  }
  clear_has_coordinates();
}
inline const ::std::string& Message_MotionRec::coordinates() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.coordinates)
  return *coordinates_;
}
inline void Message_MotionRec::set_coordinates(const ::std::string& value) {
  set_has_coordinates();
  if (coordinates_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    coordinates_ = new ::std::string;
  }
  coordinates_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.coordinates)
}
inline void Message_MotionRec::set_coordinates(const char* value) {
  set_has_coordinates();
  if (coordinates_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    coordinates_ = new ::std::string;
  }
  coordinates_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionRec.coordinates)
}
inline void Message_MotionRec::set_coordinates(const char* value, size_t size) {
  set_has_coordinates();
  if (coordinates_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    coordinates_ = new ::std::string;
  }
  coordinates_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionRec.coordinates)
}
inline ::std::string* Message_MotionRec::mutable_coordinates() {
  set_has_coordinates();
  if (coordinates_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    coordinates_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionRec.coordinates)
  return coordinates_;
}
inline ::std::string* Message_MotionRec::release_coordinates() {
  clear_has_coordinates();
  if (coordinates_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = coordinates_;
    coordinates_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionRec::set_allocated_coordinates(::std::string* coordinates) {
  if (coordinates_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete coordinates_;
  }
  if (coordinates) {
    set_has_coordinates();
    coordinates_ = coordinates;
  } else {
    clear_has_coordinates();
    coordinates_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionRec.coordinates)
}

// optional int32 delay = 12;
inline bool Message_MotionRec::has_delay() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Message_MotionRec::set_has_delay() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Message_MotionRec::clear_has_delay() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Message_MotionRec::clear_delay() {
  delay_ = 0;
  clear_has_delay();
}
inline ::google::protobuf::int32 Message_MotionRec::delay() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.delay)
  return delay_;
}
inline void Message_MotionRec::set_delay(::google::protobuf::int32 value) {
  set_has_delay();
  delay_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.delay)
}

// optional string startrectime = 13;
inline bool Message_MotionRec::has_startrectime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Message_MotionRec::set_has_startrectime() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Message_MotionRec::clear_has_startrectime() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Message_MotionRec::clear_startrectime() {
  if (startrectime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startrectime_->clear();
  }
  clear_has_startrectime();
}
inline const ::std::string& Message_MotionRec::startrectime() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.startrectime)
  return *startrectime_;
}
inline void Message_MotionRec::set_startrectime(const ::std::string& value) {
  set_has_startrectime();
  if (startrectime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startrectime_ = new ::std::string;
  }
  startrectime_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.startrectime)
}
inline void Message_MotionRec::set_startrectime(const char* value) {
  set_has_startrectime();
  if (startrectime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startrectime_ = new ::std::string;
  }
  startrectime_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionRec.startrectime)
}
inline void Message_MotionRec::set_startrectime(const char* value, size_t size) {
  set_has_startrectime();
  if (startrectime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startrectime_ = new ::std::string;
  }
  startrectime_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionRec.startrectime)
}
inline ::std::string* Message_MotionRec::mutable_startrectime() {
  set_has_startrectime();
  if (startrectime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startrectime_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionRec.startrectime)
  return startrectime_;
}
inline ::std::string* Message_MotionRec::release_startrectime() {
  clear_has_startrectime();
  if (startrectime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = startrectime_;
    startrectime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionRec::set_allocated_startrectime(::std::string* startrectime) {
  if (startrectime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete startrectime_;
  }
  if (startrectime) {
    set_has_startrectime();
    startrectime_ = startrectime;
  } else {
    clear_has_startrectime();
    startrectime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionRec.startrectime)
}

// optional string stoprectime = 14;
inline bool Message_MotionRec::has_stoprectime() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Message_MotionRec::set_has_stoprectime() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Message_MotionRec::clear_has_stoprectime() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Message_MotionRec::clear_stoprectime() {
  if (stoprectime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stoprectime_->clear();
  }
  clear_has_stoprectime();
}
inline const ::std::string& Message_MotionRec::stoprectime() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.stoprectime)
  return *stoprectime_;
}
inline void Message_MotionRec::set_stoprectime(const ::std::string& value) {
  set_has_stoprectime();
  if (stoprectime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stoprectime_ = new ::std::string;
  }
  stoprectime_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.stoprectime)
}
inline void Message_MotionRec::set_stoprectime(const char* value) {
  set_has_stoprectime();
  if (stoprectime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stoprectime_ = new ::std::string;
  }
  stoprectime_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionRec.stoprectime)
}
inline void Message_MotionRec::set_stoprectime(const char* value, size_t size) {
  set_has_stoprectime();
  if (stoprectime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stoprectime_ = new ::std::string;
  }
  stoprectime_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionRec.stoprectime)
}
inline ::std::string* Message_MotionRec::mutable_stoprectime() {
  set_has_stoprectime();
  if (stoprectime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stoprectime_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionRec.stoprectime)
  return stoprectime_;
}
inline ::std::string* Message_MotionRec::release_stoprectime() {
  clear_has_stoprectime();
  if (stoprectime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = stoprectime_;
    stoprectime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionRec::set_allocated_stoprectime(::std::string* stoprectime) {
  if (stoprectime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete stoprectime_;
  }
  if (stoprectime) {
    set_has_stoprectime();
    stoprectime_ = stoprectime;
  } else {
    clear_has_stoprectime();
    stoprectime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionRec.stoprectime)
}

// optional bool runatstartup = 15;
inline bool Message_MotionRec::has_runatstartup() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Message_MotionRec::set_has_runatstartup() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Message_MotionRec::clear_has_runatstartup() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Message_MotionRec::clear_runatstartup() {
  runatstartup_ = false;
  clear_has_runatstartup();
}
inline bool Message_MotionRec::runatstartup() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.runatstartup)
  return runatstartup_;
}
inline void Message_MotionRec::set_runatstartup(bool value) {
  set_has_runatstartup();
  runatstartup_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.runatstartup)
}

// optional int32 activemat = 16;
inline bool Message_MotionRec::has_activemat() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Message_MotionRec::set_has_activemat() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Message_MotionRec::clear_has_activemat() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Message_MotionRec::clear_activemat() {
  activemat_ = 0;
  clear_has_activemat();
}
inline ::google::protobuf::int32 Message_MotionRec::activemat() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.activemat)
  return activemat_;
}
inline void Message_MotionRec::set_activemat(::google::protobuf::int32 value) {
  set_has_activemat();
  activemat_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.activemat)
}

// optional int32 db_idmat = 17;
inline bool Message_MotionRec::has_db_idmat() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Message_MotionRec::set_has_db_idmat() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Message_MotionRec::clear_has_db_idmat() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Message_MotionRec::clear_db_idmat() {
  db_idmat_ = 0;
  clear_has_db_idmat();
}
inline ::google::protobuf::int32 Message_MotionRec::db_idmat() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.db_idmat)
  return db_idmat_;
}
inline void Message_MotionRec::set_db_idmat(::google::protobuf::int32 value) {
  set_has_db_idmat();
  db_idmat_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.db_idmat)
}

// optional int32 db_idcoordinates = 18;
inline bool Message_MotionRec::has_db_idcoordinates() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Message_MotionRec::set_has_db_idcoordinates() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Message_MotionRec::clear_has_db_idcoordinates() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Message_MotionRec::clear_db_idcoordinates() {
  db_idcoordinates_ = 0;
  clear_has_db_idcoordinates();
}
inline ::google::protobuf::int32 Message_MotionRec::db_idcoordinates() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.db_idcoordinates)
  return db_idcoordinates_;
}
inline void Message_MotionRec::set_db_idcoordinates(::google::protobuf::int32 value) {
  set_has_db_idcoordinates();
  db_idcoordinates_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.db_idcoordinates)
}

// optional int32 db_intervalid = 19;
inline bool Message_MotionRec::has_db_intervalid() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Message_MotionRec::set_has_db_intervalid() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Message_MotionRec::clear_has_db_intervalid() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Message_MotionRec::clear_db_intervalid() {
  db_intervalid_ = 0;
  clear_has_db_intervalid();
}
inline ::google::protobuf::int32 Message_MotionRec::db_intervalid() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.db_intervalid)
  return db_intervalid_;
}
inline void Message_MotionRec::set_db_intervalid(::google::protobuf::int32 value) {
  set_has_db_intervalid();
  db_intervalid_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.db_intervalid)
}

// optional int32 matcols = 20;
inline bool Message_MotionRec::has_matcols() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Message_MotionRec::set_has_matcols() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Message_MotionRec::clear_has_matcols() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Message_MotionRec::clear_matcols() {
  matcols_ = 0;
  clear_has_matcols();
}
inline ::google::protobuf::int32 Message_MotionRec::matcols() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.matcols)
  return matcols_;
}
inline void Message_MotionRec::set_matcols(::google::protobuf::int32 value) {
  set_has_matcols();
  matcols_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.matcols)
}

// optional int32 matrows = 21;
inline bool Message_MotionRec::has_matrows() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Message_MotionRec::set_has_matrows() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Message_MotionRec::clear_has_matrows() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Message_MotionRec::clear_matrows() {
  matrows_ = 0;
  clear_has_matrows();
}
inline ::google::protobuf::int32 Message_MotionRec::matrows() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.matrows)
  return matrows_;
}
inline void Message_MotionRec::set_matrows(::google::protobuf::int32 value) {
  set_has_matrows();
  matrows_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.matrows)
}

// optional int32 matwidth = 22;
inline bool Message_MotionRec::has_matwidth() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Message_MotionRec::set_has_matwidth() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Message_MotionRec::clear_has_matwidth() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Message_MotionRec::clear_matwidth() {
  matwidth_ = 0;
  clear_has_matwidth();
}
inline ::google::protobuf::int32 Message_MotionRec::matwidth() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.matwidth)
  return matwidth_;
}
inline void Message_MotionRec::set_matwidth(::google::protobuf::int32 value) {
  set_has_matwidth();
  matwidth_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.matwidth)
}

// optional int32 matheight = 23;
inline bool Message_MotionRec::has_matheight() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Message_MotionRec::set_has_matheight() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Message_MotionRec::clear_has_matheight() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Message_MotionRec::clear_matheight() {
  matheight_ = 0;
  clear_has_matheight();
}
inline ::google::protobuf::int32 Message_MotionRec::matheight() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.matheight)
  return matheight_;
}
inline void Message_MotionRec::set_matheight(::google::protobuf::int32 value) {
  set_has_matheight();
  matheight_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.matheight)
}

// optional string lastinstance = 24;
inline bool Message_MotionRec::has_lastinstance() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Message_MotionRec::set_has_lastinstance() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Message_MotionRec::clear_has_lastinstance() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Message_MotionRec::clear_lastinstance() {
  if (lastinstance_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastinstance_->clear();
  }
  clear_has_lastinstance();
}
inline const ::std::string& Message_MotionRec::lastinstance() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.lastinstance)
  return *lastinstance_;
}
inline void Message_MotionRec::set_lastinstance(const ::std::string& value) {
  set_has_lastinstance();
  if (lastinstance_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastinstance_ = new ::std::string;
  }
  lastinstance_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.lastinstance)
}
inline void Message_MotionRec::set_lastinstance(const char* value) {
  set_has_lastinstance();
  if (lastinstance_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastinstance_ = new ::std::string;
  }
  lastinstance_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionRec.lastinstance)
}
inline void Message_MotionRec::set_lastinstance(const char* value, size_t size) {
  set_has_lastinstance();
  if (lastinstance_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastinstance_ = new ::std::string;
  }
  lastinstance_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionRec.lastinstance)
}
inline ::std::string* Message_MotionRec::mutable_lastinstance() {
  set_has_lastinstance();
  if (lastinstance_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lastinstance_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionRec.lastinstance)
  return lastinstance_;
}
inline ::std::string* Message_MotionRec::release_lastinstance() {
  clear_has_lastinstance();
  if (lastinstance_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = lastinstance_;
    lastinstance_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionRec::set_allocated_lastinstance(::std::string* lastinstance) {
  if (lastinstance_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete lastinstance_;
  }
  if (lastinstance) {
    set_has_lastinstance();
    lastinstance_ = lastinstance;
  } else {
    clear_has_lastinstance();
    lastinstance_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionRec.lastinstance)
}

// optional int32 db_idmonth = 25;
inline bool Message_MotionRec::has_db_idmonth() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Message_MotionRec::set_has_db_idmonth() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Message_MotionRec::clear_has_db_idmonth() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Message_MotionRec::clear_db_idmonth() {
  db_idmonth_ = 0;
  clear_has_db_idmonth();
}
inline ::google::protobuf::int32 Message_MotionRec::db_idmonth() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.db_idmonth)
  return db_idmonth_;
}
inline void Message_MotionRec::set_db_idmonth(::google::protobuf::int32 value) {
  set_has_db_idmonth();
  db_idmonth_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.db_idmonth)
}

// optional int32 db_idday = 26;
inline bool Message_MotionRec::has_db_idday() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Message_MotionRec::set_has_db_idday() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Message_MotionRec::clear_has_db_idday() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Message_MotionRec::clear_db_idday() {
  db_idday_ = 0;
  clear_has_db_idday();
}
inline ::google::protobuf::int32 Message_MotionRec::db_idday() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.db_idday)
  return db_idday_;
}
inline void Message_MotionRec::set_db_idday(::google::protobuf::int32 value) {
  set_has_db_idday();
  db_idday_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.db_idday)
}

// optional string xmlfilepath = 27;
inline bool Message_MotionRec::has_xmlfilepath() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Message_MotionRec::set_has_xmlfilepath() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Message_MotionRec::clear_has_xmlfilepath() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Message_MotionRec::clear_xmlfilepath() {
  if (xmlfilepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xmlfilepath_->clear();
  }
  clear_has_xmlfilepath();
}
inline const ::std::string& Message_MotionRec::xmlfilepath() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.xmlfilepath)
  return *xmlfilepath_;
}
inline void Message_MotionRec::set_xmlfilepath(const ::std::string& value) {
  set_has_xmlfilepath();
  if (xmlfilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xmlfilepath_ = new ::std::string;
  }
  xmlfilepath_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.xmlfilepath)
}
inline void Message_MotionRec::set_xmlfilepath(const char* value) {
  set_has_xmlfilepath();
  if (xmlfilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xmlfilepath_ = new ::std::string;
  }
  xmlfilepath_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionRec.xmlfilepath)
}
inline void Message_MotionRec::set_xmlfilepath(const char* value, size_t size) {
  set_has_xmlfilepath();
  if (xmlfilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xmlfilepath_ = new ::std::string;
  }
  xmlfilepath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionRec.xmlfilepath)
}
inline ::std::string* Message_MotionRec::mutable_xmlfilepath() {
  set_has_xmlfilepath();
  if (xmlfilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xmlfilepath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionRec.xmlfilepath)
  return xmlfilepath_;
}
inline ::std::string* Message_MotionRec::release_xmlfilepath() {
  clear_has_xmlfilepath();
  if (xmlfilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = xmlfilepath_;
    xmlfilepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionRec::set_allocated_xmlfilepath(::std::string* xmlfilepath) {
  if (xmlfilepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete xmlfilepath_;
  }
  if (xmlfilepath) {
    set_has_xmlfilepath();
    xmlfilepath_ = xmlfilepath;
  } else {
    clear_has_xmlfilepath();
    xmlfilepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionRec.xmlfilepath)
}

// optional int32 db_recognitionsetupid = 28;
inline bool Message_MotionRec::has_db_recognitionsetupid() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Message_MotionRec::set_has_db_recognitionsetupid() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Message_MotionRec::clear_has_db_recognitionsetupid() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Message_MotionRec::clear_db_recognitionsetupid() {
  db_recognitionsetupid_ = 0;
  clear_has_db_recognitionsetupid();
}
inline ::google::protobuf::int32 Message_MotionRec::db_recognitionsetupid() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.db_recognitionsetupid)
  return db_recognitionsetupid_;
}
inline void Message_MotionRec::set_db_recognitionsetupid(::google::protobuf::int32 value) {
  set_has_db_recognitionsetupid();
  db_recognitionsetupid_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.db_recognitionsetupid)
}

// optional bool hascron = 29;
inline bool Message_MotionRec::has_hascron() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Message_MotionRec::set_has_hascron() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Message_MotionRec::clear_has_hascron() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Message_MotionRec::clear_hascron() {
  hascron_ = false;
  clear_has_hascron();
}
inline bool Message_MotionRec::hascron() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.hascron)
  return hascron_;
}
inline void Message_MotionRec::set_hascron(bool value) {
  set_has_hascron();
  hascron_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.hascron)
}

// repeated .motion.Message.MotionCron motioncron = 30;
inline int Message_MotionRec::motioncron_size() const {
  return motioncron_.size();
}
inline void Message_MotionRec::clear_motioncron() {
  motioncron_.Clear();
}
inline const ::motion::Message_MotionCron& Message_MotionRec::motioncron(int index) const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.motioncron)
  return motioncron_.Get(index);
}
inline ::motion::Message_MotionCron* Message_MotionRec::mutable_motioncron(int index) {
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionRec.motioncron)
  return motioncron_.Mutable(index);
}
inline ::motion::Message_MotionCron* Message_MotionRec::add_motioncron() {
  // @@protoc_insertion_point(field_add:motion.Message.MotionRec.motioncron)
  return motioncron_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionCron >&
Message_MotionRec::motioncron() const {
  // @@protoc_insertion_point(field_list:motion.Message.MotionRec.motioncron)
  return motioncron_;
}
inline ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionCron >*
Message_MotionRec::mutable_motioncron() {
  // @@protoc_insertion_point(field_mutable_list:motion.Message.MotionRec.motioncron)
  return &motioncron_;
}

// optional int32 speed = 31;
inline bool Message_MotionRec::has_speed() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Message_MotionRec::set_has_speed() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Message_MotionRec::clear_has_speed() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Message_MotionRec::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline ::google::protobuf::int32 Message_MotionRec::speed() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.speed)
  return speed_;
}
inline void Message_MotionRec::set_speed(::google::protobuf::int32 value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.speed)
}

// optional int32 activerec = 32;
inline bool Message_MotionRec::has_activerec() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void Message_MotionRec::set_has_activerec() {
  _has_bits_[0] |= 0x80000000u;
}
inline void Message_MotionRec::clear_has_activerec() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void Message_MotionRec::clear_activerec() {
  activerec_ = 0;
  clear_has_activerec();
}
inline ::google::protobuf::int32 Message_MotionRec::activerec() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.activerec)
  return activerec_;
}
inline void Message_MotionRec::set_activerec(::google::protobuf::int32 value) {
  set_has_activerec();
  activerec_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.activerec)
}

// optional string matbasefile = 33;
inline bool Message_MotionRec::has_matbasefile() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void Message_MotionRec::set_has_matbasefile() {
  _has_bits_[1] |= 0x00000001u;
}
inline void Message_MotionRec::clear_has_matbasefile() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void Message_MotionRec::clear_matbasefile() {
  if (matbasefile_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    matbasefile_->clear();
  }
  clear_has_matbasefile();
}
inline const ::std::string& Message_MotionRec::matbasefile() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.matbasefile)
  return *matbasefile_;
}
inline void Message_MotionRec::set_matbasefile(const ::std::string& value) {
  set_has_matbasefile();
  if (matbasefile_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    matbasefile_ = new ::std::string;
  }
  matbasefile_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.matbasefile)
}
inline void Message_MotionRec::set_matbasefile(const char* value) {
  set_has_matbasefile();
  if (matbasefile_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    matbasefile_ = new ::std::string;
  }
  matbasefile_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionRec.matbasefile)
}
inline void Message_MotionRec::set_matbasefile(const char* value, size_t size) {
  set_has_matbasefile();
  if (matbasefile_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    matbasefile_ = new ::std::string;
  }
  matbasefile_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionRec.matbasefile)
}
inline ::std::string* Message_MotionRec::mutable_matbasefile() {
  set_has_matbasefile();
  if (matbasefile_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    matbasefile_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionRec.matbasefile)
  return matbasefile_;
}
inline ::std::string* Message_MotionRec::release_matbasefile() {
  clear_has_matbasefile();
  if (matbasefile_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = matbasefile_;
    matbasefile_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionRec::set_allocated_matbasefile(::std::string* matbasefile) {
  if (matbasefile_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete matbasefile_;
  }
  if (matbasefile) {
    set_has_matbasefile();
    matbasefile_ = matbasefile;
  } else {
    clear_has_matbasefile();
    matbasefile_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionRec.matbasefile)
}

// optional string created = 34;
inline bool Message_MotionRec::has_created() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void Message_MotionRec::set_has_created() {
  _has_bits_[1] |= 0x00000002u;
}
inline void Message_MotionRec::clear_has_created() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void Message_MotionRec::clear_created() {
  if (created_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    created_->clear();
  }
  clear_has_created();
}
inline const ::std::string& Message_MotionRec::created() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionRec.created)
  return *created_;
}
inline void Message_MotionRec::set_created(const ::std::string& value) {
  set_has_created();
  if (created_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    created_ = new ::std::string;
  }
  created_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionRec.created)
}
inline void Message_MotionRec::set_created(const char* value) {
  set_has_created();
  if (created_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    created_ = new ::std::string;
  }
  created_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionRec.created)
}
inline void Message_MotionRec::set_created(const char* value, size_t size) {
  set_has_created();
  if (created_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    created_ = new ::std::string;
  }
  created_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionRec.created)
}
inline ::std::string* Message_MotionRec::mutable_created() {
  set_has_created();
  if (created_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    created_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionRec.created)
  return created_;
}
inline ::std::string* Message_MotionRec::release_created() {
  clear_has_created();
  if (created_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = created_;
    created_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionRec::set_allocated_created(::std::string* created) {
  if (created_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete created_;
  }
  if (created) {
    set_has_created();
    created_ = created;
  } else {
    clear_has_created();
    created_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionRec.created)
}

// -------------------------------------------------------------------

// Message_MotionCron

// optional string command = 1;
inline bool Message_MotionCron::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message_MotionCron::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message_MotionCron::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message_MotionCron::clear_command() {
  if (command_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_->clear();
  }
  clear_has_command();
}
inline const ::std::string& Message_MotionCron::command() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionCron.command)
  return *command_;
}
inline void Message_MotionCron::set_command(const ::std::string& value) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  command_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionCron.command)
}
inline void Message_MotionCron::set_command(const char* value) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  command_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionCron.command)
}
inline void Message_MotionCron::set_command(const char* value, size_t size) {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  command_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionCron.command)
}
inline ::std::string* Message_MotionCron::mutable_command() {
  set_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    command_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionCron.command)
  return command_;
}
inline ::std::string* Message_MotionCron::release_command() {
  clear_has_command();
  if (command_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = command_;
    command_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionCron::set_allocated_command(::std::string* command) {
  if (command_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete command_;
  }
  if (command) {
    set_has_command();
    command_ = command;
  } else {
    clear_has_command();
    command_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionCron.command)
}

// optional string program = 2;
inline bool Message_MotionCron::has_program() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message_MotionCron::set_has_program() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message_MotionCron::clear_has_program() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message_MotionCron::clear_program() {
  if (program_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    program_->clear();
  }
  clear_has_program();
}
inline const ::std::string& Message_MotionCron::program() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionCron.program)
  return *program_;
}
inline void Message_MotionCron::set_program(const ::std::string& value) {
  set_has_program();
  if (program_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    program_ = new ::std::string;
  }
  program_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionCron.program)
}
inline void Message_MotionCron::set_program(const char* value) {
  set_has_program();
  if (program_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    program_ = new ::std::string;
  }
  program_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionCron.program)
}
inline void Message_MotionCron::set_program(const char* value, size_t size) {
  set_has_program();
  if (program_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    program_ = new ::std::string;
  }
  program_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionCron.program)
}
inline ::std::string* Message_MotionCron::mutable_program() {
  set_has_program();
  if (program_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    program_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionCron.program)
  return program_;
}
inline ::std::string* Message_MotionCron::release_program() {
  clear_has_program();
  if (program_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = program_;
    program_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionCron::set_allocated_program(::std::string* program) {
  if (program_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete program_;
  }
  if (program) {
    set_has_program();
    program_ = program;
  } else {
    clear_has_program();
    program_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionCron.program)
}

// -------------------------------------------------------------------

// Message_MotionMonth

// repeated .motion.Message.MotionDay motionday = 1;
inline int Message_MotionMonth::motionday_size() const {
  return motionday_.size();
}
inline void Message_MotionMonth::clear_motionday() {
  motionday_.Clear();
}
inline const ::motion::Message_MotionDay& Message_MotionMonth::motionday(int index) const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionMonth.motionday)
  return motionday_.Get(index);
}
inline ::motion::Message_MotionDay* Message_MotionMonth::mutable_motionday(int index) {
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionMonth.motionday)
  return motionday_.Mutable(index);
}
inline ::motion::Message_MotionDay* Message_MotionMonth::add_motionday() {
  // @@protoc_insertion_point(field_add:motion.Message.MotionMonth.motionday)
  return motionday_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionDay >&
Message_MotionMonth::motionday() const {
  // @@protoc_insertion_point(field_list:motion.Message.MotionMonth.motionday)
  return motionday_;
}
inline ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionDay >*
Message_MotionMonth::mutable_motionday() {
  // @@protoc_insertion_point(field_mutable_list:motion.Message.MotionMonth.motionday)
  return &motionday_;
}

// optional string monthlabel = 2;
inline bool Message_MotionMonth::has_monthlabel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message_MotionMonth::set_has_monthlabel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message_MotionMonth::clear_has_monthlabel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message_MotionMonth::clear_monthlabel() {
  if (monthlabel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    monthlabel_->clear();
  }
  clear_has_monthlabel();
}
inline const ::std::string& Message_MotionMonth::monthlabel() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionMonth.monthlabel)
  return *monthlabel_;
}
inline void Message_MotionMonth::set_monthlabel(const ::std::string& value) {
  set_has_monthlabel();
  if (monthlabel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    monthlabel_ = new ::std::string;
  }
  monthlabel_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionMonth.monthlabel)
}
inline void Message_MotionMonth::set_monthlabel(const char* value) {
  set_has_monthlabel();
  if (monthlabel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    monthlabel_ = new ::std::string;
  }
  monthlabel_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionMonth.monthlabel)
}
inline void Message_MotionMonth::set_monthlabel(const char* value, size_t size) {
  set_has_monthlabel();
  if (monthlabel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    monthlabel_ = new ::std::string;
  }
  monthlabel_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionMonth.monthlabel)
}
inline ::std::string* Message_MotionMonth::mutable_monthlabel() {
  set_has_monthlabel();
  if (monthlabel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    monthlabel_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionMonth.monthlabel)
  return monthlabel_;
}
inline ::std::string* Message_MotionMonth::release_monthlabel() {
  clear_has_monthlabel();
  if (monthlabel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = monthlabel_;
    monthlabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionMonth::set_allocated_monthlabel(::std::string* monthlabel) {
  if (monthlabel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete monthlabel_;
  }
  if (monthlabel) {
    set_has_monthlabel();
    monthlabel_ = monthlabel;
  } else {
    clear_has_monthlabel();
    monthlabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionMonth.monthlabel)
}

// optional int32 db_monthid = 3;
inline bool Message_MotionMonth::has_db_monthid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message_MotionMonth::set_has_db_monthid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message_MotionMonth::clear_has_db_monthid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message_MotionMonth::clear_db_monthid() {
  db_monthid_ = 0;
  clear_has_db_monthid();
}
inline ::google::protobuf::int32 Message_MotionMonth::db_monthid() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionMonth.db_monthid)
  return db_monthid_;
}
inline void Message_MotionMonth::set_db_monthid(::google::protobuf::int32 value) {
  set_has_db_monthid();
  db_monthid_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionMonth.db_monthid)
}

// -------------------------------------------------------------------

// Message_MotionDay

// repeated .motion.Message.Instance instance = 1;
inline int Message_MotionDay::instance_size() const {
  return instance_.size();
}
inline void Message_MotionDay::clear_instance() {
  instance_.Clear();
}
inline const ::motion::Message_Instance& Message_MotionDay::instance(int index) const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionDay.instance)
  return instance_.Get(index);
}
inline ::motion::Message_Instance* Message_MotionDay::mutable_instance(int index) {
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionDay.instance)
  return instance_.Mutable(index);
}
inline ::motion::Message_Instance* Message_MotionDay::add_instance() {
  // @@protoc_insertion_point(field_add:motion.Message.MotionDay.instance)
  return instance_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_Instance >&
Message_MotionDay::instance() const {
  // @@protoc_insertion_point(field_list:motion.Message.MotionDay.instance)
  return instance_;
}
inline ::google::protobuf::RepeatedPtrField< ::motion::Message_Instance >*
Message_MotionDay::mutable_instance() {
  // @@protoc_insertion_point(field_mutable_list:motion.Message.MotionDay.instance)
  return &instance_;
}

// optional string daylabel = 2;
inline bool Message_MotionDay::has_daylabel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message_MotionDay::set_has_daylabel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message_MotionDay::clear_has_daylabel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message_MotionDay::clear_daylabel() {
  if (daylabel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daylabel_->clear();
  }
  clear_has_daylabel();
}
inline const ::std::string& Message_MotionDay::daylabel() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionDay.daylabel)
  return *daylabel_;
}
inline void Message_MotionDay::set_daylabel(const ::std::string& value) {
  set_has_daylabel();
  if (daylabel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daylabel_ = new ::std::string;
  }
  daylabel_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionDay.daylabel)
}
inline void Message_MotionDay::set_daylabel(const char* value) {
  set_has_daylabel();
  if (daylabel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daylabel_ = new ::std::string;
  }
  daylabel_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionDay.daylabel)
}
inline void Message_MotionDay::set_daylabel(const char* value, size_t size) {
  set_has_daylabel();
  if (daylabel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daylabel_ = new ::std::string;
  }
  daylabel_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionDay.daylabel)
}
inline ::std::string* Message_MotionDay::mutable_daylabel() {
  set_has_daylabel();
  if (daylabel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daylabel_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionDay.daylabel)
  return daylabel_;
}
inline ::std::string* Message_MotionDay::release_daylabel() {
  clear_has_daylabel();
  if (daylabel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = daylabel_;
    daylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionDay::set_allocated_daylabel(::std::string* daylabel) {
  if (daylabel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete daylabel_;
  }
  if (daylabel) {
    set_has_daylabel();
    daylabel_ = daylabel;
  } else {
    clear_has_daylabel();
    daylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionDay.daylabel)
}

// optional int32 db_dayid = 3;
inline bool Message_MotionDay::has_db_dayid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message_MotionDay::set_has_db_dayid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message_MotionDay::clear_has_db_dayid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message_MotionDay::clear_db_dayid() {
  db_dayid_ = 0;
  clear_has_db_dayid();
}
inline ::google::protobuf::int32 Message_MotionDay::db_dayid() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionDay.db_dayid)
  return db_dayid_;
}
inline void Message_MotionDay::set_db_dayid(::google::protobuf::int32 value) {
  set_has_db_dayid();
  db_dayid_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.MotionDay.db_dayid)
}

// optional string xmlfilepath = 4;
inline bool Message_MotionDay::has_xmlfilepath() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message_MotionDay::set_has_xmlfilepath() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message_MotionDay::clear_has_xmlfilepath() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message_MotionDay::clear_xmlfilepath() {
  if (xmlfilepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xmlfilepath_->clear();
  }
  clear_has_xmlfilepath();
}
inline const ::std::string& Message_MotionDay::xmlfilepath() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionDay.xmlfilepath)
  return *xmlfilepath_;
}
inline void Message_MotionDay::set_xmlfilepath(const ::std::string& value) {
  set_has_xmlfilepath();
  if (xmlfilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xmlfilepath_ = new ::std::string;
  }
  xmlfilepath_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionDay.xmlfilepath)
}
inline void Message_MotionDay::set_xmlfilepath(const char* value) {
  set_has_xmlfilepath();
  if (xmlfilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xmlfilepath_ = new ::std::string;
  }
  xmlfilepath_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionDay.xmlfilepath)
}
inline void Message_MotionDay::set_xmlfilepath(const char* value, size_t size) {
  set_has_xmlfilepath();
  if (xmlfilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xmlfilepath_ = new ::std::string;
  }
  xmlfilepath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionDay.xmlfilepath)
}
inline ::std::string* Message_MotionDay::mutable_xmlfilepath() {
  set_has_xmlfilepath();
  if (xmlfilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xmlfilepath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionDay.xmlfilepath)
  return xmlfilepath_;
}
inline ::std::string* Message_MotionDay::release_xmlfilepath() {
  clear_has_xmlfilepath();
  if (xmlfilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = xmlfilepath_;
    xmlfilepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionDay::set_allocated_xmlfilepath(::std::string* xmlfilepath) {
  if (xmlfilepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete xmlfilepath_;
  }
  if (xmlfilepath) {
    set_has_xmlfilepath();
    xmlfilepath_ = xmlfilepath;
  } else {
    clear_has_xmlfilepath();
    xmlfilepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionDay.xmlfilepath)
}

// optional string title = 5;
inline bool Message_MotionDay::has_title() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message_MotionDay::set_has_title() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message_MotionDay::clear_has_title() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message_MotionDay::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& Message_MotionDay::title() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionDay.title)
  return *title_;
}
inline void Message_MotionDay::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionDay.title)
}
inline void Message_MotionDay::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionDay.title)
}
inline void Message_MotionDay::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionDay.title)
}
inline ::std::string* Message_MotionDay::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    title_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionDay.title)
  return title_;
}
inline ::std::string* Message_MotionDay::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionDay::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionDay.title)
}

// -------------------------------------------------------------------

// Message_Instance

// required int32 idinstance = 1;
inline bool Message_Instance::has_idinstance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message_Instance::set_has_idinstance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message_Instance::clear_has_idinstance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message_Instance::clear_idinstance() {
  idinstance_ = 0;
  clear_has_idinstance();
}
inline ::google::protobuf::int32 Message_Instance::idinstance() const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.idinstance)
  return idinstance_;
}
inline void Message_Instance::set_idinstance(::google::protobuf::int32 value) {
  set_has_idinstance();
  idinstance_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.Instance.idinstance)
}

// optional int32 number = 2;
inline bool Message_Instance::has_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message_Instance::set_has_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message_Instance::clear_has_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message_Instance::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 Message_Instance::number() const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.number)
  return number_;
}
inline void Message_Instance::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.Instance.number)
}

// optional string instancestart = 3;
inline bool Message_Instance::has_instancestart() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message_Instance::set_has_instancestart() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message_Instance::clear_has_instancestart() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message_Instance::clear_instancestart() {
  if (instancestart_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instancestart_->clear();
  }
  clear_has_instancestart();
}
inline const ::std::string& Message_Instance::instancestart() const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.instancestart)
  return *instancestart_;
}
inline void Message_Instance::set_instancestart(const ::std::string& value) {
  set_has_instancestart();
  if (instancestart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instancestart_ = new ::std::string;
  }
  instancestart_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.Instance.instancestart)
}
inline void Message_Instance::set_instancestart(const char* value) {
  set_has_instancestart();
  if (instancestart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instancestart_ = new ::std::string;
  }
  instancestart_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.Instance.instancestart)
}
inline void Message_Instance::set_instancestart(const char* value, size_t size) {
  set_has_instancestart();
  if (instancestart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instancestart_ = new ::std::string;
  }
  instancestart_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.Instance.instancestart)
}
inline ::std::string* Message_Instance::mutable_instancestart() {
  set_has_instancestart();
  if (instancestart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instancestart_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.Instance.instancestart)
  return instancestart_;
}
inline ::std::string* Message_Instance::release_instancestart() {
  clear_has_instancestart();
  if (instancestart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = instancestart_;
    instancestart_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_Instance::set_allocated_instancestart(::std::string* instancestart) {
  if (instancestart_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete instancestart_;
  }
  if (instancestart) {
    set_has_instancestart();
    instancestart_ = instancestart;
  } else {
    clear_has_instancestart();
    instancestart_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Instance.instancestart)
}

// optional string instanceend = 4;
inline bool Message_Instance::has_instanceend() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message_Instance::set_has_instanceend() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message_Instance::clear_has_instanceend() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message_Instance::clear_instanceend() {
  if (instanceend_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instanceend_->clear();
  }
  clear_has_instanceend();
}
inline const ::std::string& Message_Instance::instanceend() const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.instanceend)
  return *instanceend_;
}
inline void Message_Instance::set_instanceend(const ::std::string& value) {
  set_has_instanceend();
  if (instanceend_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instanceend_ = new ::std::string;
  }
  instanceend_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.Instance.instanceend)
}
inline void Message_Instance::set_instanceend(const char* value) {
  set_has_instanceend();
  if (instanceend_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instanceend_ = new ::std::string;
  }
  instanceend_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.Instance.instanceend)
}
inline void Message_Instance::set_instanceend(const char* value, size_t size) {
  set_has_instanceend();
  if (instanceend_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instanceend_ = new ::std::string;
  }
  instanceend_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.Instance.instanceend)
}
inline ::std::string* Message_Instance::mutable_instanceend() {
  set_has_instanceend();
  if (instanceend_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instanceend_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.Instance.instanceend)
  return instanceend_;
}
inline ::std::string* Message_Instance::release_instanceend() {
  clear_has_instanceend();
  if (instanceend_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = instanceend_;
    instanceend_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_Instance::set_allocated_instanceend(::std::string* instanceend) {
  if (instanceend_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete instanceend_;
  }
  if (instanceend) {
    set_has_instanceend();
    instanceend_ = instanceend;
  } else {
    clear_has_instanceend();
    instanceend_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Instance.instanceend)
}

// optional string fileformat = 5;
inline bool Message_Instance::has_fileformat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message_Instance::set_has_fileformat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message_Instance::clear_has_fileformat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message_Instance::clear_fileformat() {
  if (fileformat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fileformat_->clear();
  }
  clear_has_fileformat();
}
inline const ::std::string& Message_Instance::fileformat() const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.fileformat)
  return *fileformat_;
}
inline void Message_Instance::set_fileformat(const ::std::string& value) {
  set_has_fileformat();
  if (fileformat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fileformat_ = new ::std::string;
  }
  fileformat_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.Instance.fileformat)
}
inline void Message_Instance::set_fileformat(const char* value) {
  set_has_fileformat();
  if (fileformat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fileformat_ = new ::std::string;
  }
  fileformat_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.Instance.fileformat)
}
inline void Message_Instance::set_fileformat(const char* value, size_t size) {
  set_has_fileformat();
  if (fileformat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fileformat_ = new ::std::string;
  }
  fileformat_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.Instance.fileformat)
}
inline ::std::string* Message_Instance::mutable_fileformat() {
  set_has_fileformat();
  if (fileformat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fileformat_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.Instance.fileformat)
  return fileformat_;
}
inline ::std::string* Message_Instance::release_fileformat() {
  clear_has_fileformat();
  if (fileformat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fileformat_;
    fileformat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_Instance::set_allocated_fileformat(::std::string* fileformat) {
  if (fileformat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fileformat_;
  }
  if (fileformat) {
    set_has_fileformat();
    fileformat_ = fileformat;
  } else {
    clear_has_fileformat();
    fileformat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Instance.fileformat)
}

// repeated .motion.Message.Image image = 6;
inline int Message_Instance::image_size() const {
  return image_.size();
}
inline void Message_Instance::clear_image() {
  image_.Clear();
}
inline const ::motion::Message_Image& Message_Instance::image(int index) const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.image)
  return image_.Get(index);
}
inline ::motion::Message_Image* Message_Instance::mutable_image(int index) {
  // @@protoc_insertion_point(field_mutable:motion.Message.Instance.image)
  return image_.Mutable(index);
}
inline ::motion::Message_Image* Message_Instance::add_image() {
  // @@protoc_insertion_point(field_add:motion.Message.Instance.image)
  return image_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_Image >&
Message_Instance::image() const {
  // @@protoc_insertion_point(field_list:motion.Message.Instance.image)
  return image_;
}
inline ::google::protobuf::RepeatedPtrField< ::motion::Message_Image >*
Message_Instance::mutable_image() {
  // @@protoc_insertion_point(field_mutable_list:motion.Message.Instance.image)
  return &image_;
}

// repeated .motion.Message.Crop crop = 7;
inline int Message_Instance::crop_size() const {
  return crop_.size();
}
inline void Message_Instance::clear_crop() {
  crop_.Clear();
}
inline const ::motion::Message_Crop& Message_Instance::crop(int index) const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.crop)
  return crop_.Get(index);
}
inline ::motion::Message_Crop* Message_Instance::mutable_crop(int index) {
  // @@protoc_insertion_point(field_mutable:motion.Message.Instance.crop)
  return crop_.Mutable(index);
}
inline ::motion::Message_Crop* Message_Instance::add_crop() {
  // @@protoc_insertion_point(field_add:motion.Message.Instance.crop)
  return crop_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_Crop >&
Message_Instance::crop() const {
  // @@protoc_insertion_point(field_list:motion.Message.Instance.crop)
  return crop_;
}
inline ::google::protobuf::RepeatedPtrField< ::motion::Message_Crop >*
Message_Instance::mutable_crop() {
  // @@protoc_insertion_point(field_mutable_list:motion.Message.Instance.crop)
  return &crop_;
}

// optional .motion.Message.Video video = 8;
inline bool Message_Instance::has_video() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Message_Instance::set_has_video() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Message_Instance::clear_has_video() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Message_Instance::clear_video() {
  if (video_ != NULL) video_->::motion::Message_Video::Clear();
  clear_has_video();
}
inline const ::motion::Message_Video& Message_Instance::video() const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.video)
  return video_ != NULL ? *video_ : *default_instance_->video_;
}
inline ::motion::Message_Video* Message_Instance::mutable_video() {
  set_has_video();
  if (video_ == NULL) video_ = new ::motion::Message_Video;
  // @@protoc_insertion_point(field_mutable:motion.Message.Instance.video)
  return video_;
}
inline ::motion::Message_Video* Message_Instance::release_video() {
  clear_has_video();
  ::motion::Message_Video* temp = video_;
  video_ = NULL;
  return temp;
}
inline void Message_Instance::set_allocated_video(::motion::Message_Video* video) {
  delete video_;
  video_ = video;
  if (video) {
    set_has_video();
  } else {
    clear_has_video();
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Instance.video)
}

// optional string dir = 9;
inline bool Message_Instance::has_dir() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Message_Instance::set_has_dir() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Message_Instance::clear_has_dir() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Message_Instance::clear_dir() {
  if (dir_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dir_->clear();
  }
  clear_has_dir();
}
inline const ::std::string& Message_Instance::dir() const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.dir)
  return *dir_;
}
inline void Message_Instance::set_dir(const ::std::string& value) {
  set_has_dir();
  if (dir_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dir_ = new ::std::string;
  }
  dir_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.Instance.dir)
}
inline void Message_Instance::set_dir(const char* value) {
  set_has_dir();
  if (dir_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dir_ = new ::std::string;
  }
  dir_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.Instance.dir)
}
inline void Message_Instance::set_dir(const char* value, size_t size) {
  set_has_dir();
  if (dir_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dir_ = new ::std::string;
  }
  dir_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.Instance.dir)
}
inline ::std::string* Message_Instance::mutable_dir() {
  set_has_dir();
  if (dir_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dir_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.Instance.dir)
  return dir_;
}
inline ::std::string* Message_Instance::release_dir() {
  clear_has_dir();
  if (dir_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = dir_;
    dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_Instance::set_allocated_dir(::std::string* dir) {
  if (dir_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dir_;
  }
  if (dir) {
    set_has_dir();
    dir_ = dir;
  } else {
    clear_has_dir();
    dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Instance.dir)
}

// optional string xmlfile = 10;
inline bool Message_Instance::has_xmlfile() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Message_Instance::set_has_xmlfile() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Message_Instance::clear_has_xmlfile() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Message_Instance::clear_xmlfile() {
  if (xmlfile_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xmlfile_->clear();
  }
  clear_has_xmlfile();
}
inline const ::std::string& Message_Instance::xmlfile() const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.xmlfile)
  return *xmlfile_;
}
inline void Message_Instance::set_xmlfile(const ::std::string& value) {
  set_has_xmlfile();
  if (xmlfile_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xmlfile_ = new ::std::string;
  }
  xmlfile_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.Instance.xmlfile)
}
inline void Message_Instance::set_xmlfile(const char* value) {
  set_has_xmlfile();
  if (xmlfile_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xmlfile_ = new ::std::string;
  }
  xmlfile_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.Instance.xmlfile)
}
inline void Message_Instance::set_xmlfile(const char* value, size_t size) {
  set_has_xmlfile();
  if (xmlfile_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xmlfile_ = new ::std::string;
  }
  xmlfile_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.Instance.xmlfile)
}
inline ::std::string* Message_Instance::mutable_xmlfile() {
  set_has_xmlfile();
  if (xmlfile_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xmlfile_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.Instance.xmlfile)
  return xmlfile_;
}
inline ::std::string* Message_Instance::release_xmlfile() {
  clear_has_xmlfile();
  if (xmlfile_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = xmlfile_;
    xmlfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_Instance::set_allocated_xmlfile(::std::string* xmlfile) {
  if (xmlfile_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete xmlfile_;
  }
  if (xmlfile) {
    set_has_xmlfile();
    xmlfile_ = xmlfile;
  } else {
    clear_has_xmlfile();
    xmlfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Instance.xmlfile)
}

// optional string extdata = 11;
inline bool Message_Instance::has_extdata() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Message_Instance::set_has_extdata() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Message_Instance::clear_has_extdata() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Message_Instance::clear_extdata() {
  if (extdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extdata_->clear();
  }
  clear_has_extdata();
}
inline const ::std::string& Message_Instance::extdata() const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.extdata)
  return *extdata_;
}
inline void Message_Instance::set_extdata(const ::std::string& value) {
  set_has_extdata();
  if (extdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extdata_ = new ::std::string;
  }
  extdata_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.Instance.extdata)
}
inline void Message_Instance::set_extdata(const char* value) {
  set_has_extdata();
  if (extdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extdata_ = new ::std::string;
  }
  extdata_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.Instance.extdata)
}
inline void Message_Instance::set_extdata(const char* value, size_t size) {
  set_has_extdata();
  if (extdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extdata_ = new ::std::string;
  }
  extdata_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.Instance.extdata)
}
inline ::std::string* Message_Instance::mutable_extdata() {
  set_has_extdata();
  if (extdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extdata_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.Instance.extdata)
  return extdata_;
}
inline ::std::string* Message_Instance::release_extdata() {
  clear_has_extdata();
  if (extdata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = extdata_;
    extdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_Instance::set_allocated_extdata(::std::string* extdata) {
  if (extdata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete extdata_;
  }
  if (extdata) {
    set_has_extdata();
    extdata_ = extdata;
  } else {
    clear_has_extdata();
    extdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Instance.extdata)
}

// optional string end = 12;
inline bool Message_Instance::has_end() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Message_Instance::set_has_end() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Message_Instance::clear_has_end() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Message_Instance::clear_end() {
  if (end_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_->clear();
  }
  clear_has_end();
}
inline const ::std::string& Message_Instance::end() const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.end)
  return *end_;
}
inline void Message_Instance::set_end(const ::std::string& value) {
  set_has_end();
  if (end_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_ = new ::std::string;
  }
  end_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.Instance.end)
}
inline void Message_Instance::set_end(const char* value) {
  set_has_end();
  if (end_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_ = new ::std::string;
  }
  end_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.Instance.end)
}
inline void Message_Instance::set_end(const char* value, size_t size) {
  set_has_end();
  if (end_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_ = new ::std::string;
  }
  end_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.Instance.end)
}
inline ::std::string* Message_Instance::mutable_end() {
  set_has_end();
  if (end_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.Instance.end)
  return end_;
}
inline ::std::string* Message_Instance::release_end() {
  clear_has_end();
  if (end_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_;
    end_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_Instance::set_allocated_end(::std::string* end) {
  if (end_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_;
  }
  if (end) {
    set_has_end();
    end_ = end;
  } else {
    clear_has_end();
    end_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Instance.end)
}

// optional int32 begintime = 13;
inline bool Message_Instance::has_begintime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Message_Instance::set_has_begintime() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Message_Instance::clear_has_begintime() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Message_Instance::clear_begintime() {
  begintime_ = 0;
  clear_has_begintime();
}
inline ::google::protobuf::int32 Message_Instance::begintime() const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.begintime)
  return begintime_;
}
inline void Message_Instance::set_begintime(::google::protobuf::int32 value) {
  set_has_begintime();
  begintime_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.Instance.begintime)
}

// optional int32 endtime = 14;
inline bool Message_Instance::has_endtime() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Message_Instance::set_has_endtime() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Message_Instance::clear_has_endtime() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Message_Instance::clear_endtime() {
  endtime_ = 0;
  clear_has_endtime();
}
inline ::google::protobuf::int32 Message_Instance::endtime() const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.endtime)
  return endtime_;
}
inline void Message_Instance::set_endtime(::google::protobuf::int32 value) {
  set_has_endtime();
  endtime_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.Instance.endtime)
}

// optional int32 inittime = 15;
inline bool Message_Instance::has_inittime() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Message_Instance::set_has_inittime() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Message_Instance::clear_has_inittime() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Message_Instance::clear_inittime() {
  inittime_ = 0;
  clear_has_inittime();
}
inline ::google::protobuf::int32 Message_Instance::inittime() const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.inittime)
  return inittime_;
}
inline void Message_Instance::set_inittime(::google::protobuf::int32 value) {
  set_has_inittime();
  inittime_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.Instance.inittime)
}

// optional string instance = 16;
inline bool Message_Instance::has_instance() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Message_Instance::set_has_instance() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Message_Instance::clear_has_instance() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Message_Instance::clear_instance() {
  if (instance_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instance_->clear();
  }
  clear_has_instance();
}
inline const ::std::string& Message_Instance::instance() const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.instance)
  return *instance_;
}
inline void Message_Instance::set_instance(const ::std::string& value) {
  set_has_instance();
  if (instance_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instance_ = new ::std::string;
  }
  instance_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.Instance.instance)
}
inline void Message_Instance::set_instance(const char* value) {
  set_has_instance();
  if (instance_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instance_ = new ::std::string;
  }
  instance_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.Instance.instance)
}
inline void Message_Instance::set_instance(const char* value, size_t size) {
  set_has_instance();
  if (instance_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instance_ = new ::std::string;
  }
  instance_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.Instance.instance)
}
inline ::std::string* Message_Instance::mutable_instance() {
  set_has_instance();
  if (instance_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instance_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.Instance.instance)
  return instance_;
}
inline ::std::string* Message_Instance::release_instance() {
  clear_has_instance();
  if (instance_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = instance_;
    instance_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_Instance::set_allocated_instance(::std::string* instance) {
  if (instance_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete instance_;
  }
  if (instance) {
    set_has_instance();
    instance_ = instance;
  } else {
    clear_has_instance();
    instance_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Instance.instance)
}

// optional string instancecode = 17;
inline bool Message_Instance::has_instancecode() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Message_Instance::set_has_instancecode() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Message_Instance::clear_has_instancecode() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Message_Instance::clear_instancecode() {
  if (instancecode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instancecode_->clear();
  }
  clear_has_instancecode();
}
inline const ::std::string& Message_Instance::instancecode() const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.instancecode)
  return *instancecode_;
}
inline void Message_Instance::set_instancecode(const ::std::string& value) {
  set_has_instancecode();
  if (instancecode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instancecode_ = new ::std::string;
  }
  instancecode_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.Instance.instancecode)
}
inline void Message_Instance::set_instancecode(const char* value) {
  set_has_instancecode();
  if (instancecode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instancecode_ = new ::std::string;
  }
  instancecode_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.Instance.instancecode)
}
inline void Message_Instance::set_instancecode(const char* value, size_t size) {
  set_has_instancecode();
  if (instancecode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instancecode_ = new ::std::string;
  }
  instancecode_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.Instance.instancecode)
}
inline ::std::string* Message_Instance::mutable_instancecode() {
  set_has_instancecode();
  if (instancecode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instancecode_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.Instance.instancecode)
  return instancecode_;
}
inline ::std::string* Message_Instance::release_instancecode() {
  clear_has_instancecode();
  if (instancecode_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = instancecode_;
    instancecode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_Instance::set_allocated_instancecode(::std::string* instancecode) {
  if (instancecode_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete instancecode_;
  }
  if (instancecode) {
    set_has_instancecode();
    instancecode_ = instancecode;
  } else {
    clear_has_instancecode();
    instancecode_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Instance.instancecode)
}

// optional string timeinfo = 18;
inline bool Message_Instance::has_timeinfo() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Message_Instance::set_has_timeinfo() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Message_Instance::clear_has_timeinfo() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Message_Instance::clear_timeinfo() {
  if (timeinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    timeinfo_->clear();
  }
  clear_has_timeinfo();
}
inline const ::std::string& Message_Instance::timeinfo() const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.timeinfo)
  return *timeinfo_;
}
inline void Message_Instance::set_timeinfo(const ::std::string& value) {
  set_has_timeinfo();
  if (timeinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    timeinfo_ = new ::std::string;
  }
  timeinfo_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.Instance.timeinfo)
}
inline void Message_Instance::set_timeinfo(const char* value) {
  set_has_timeinfo();
  if (timeinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    timeinfo_ = new ::std::string;
  }
  timeinfo_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.Instance.timeinfo)
}
inline void Message_Instance::set_timeinfo(const char* value, size_t size) {
  set_has_timeinfo();
  if (timeinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    timeinfo_ = new ::std::string;
  }
  timeinfo_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.Instance.timeinfo)
}
inline ::std::string* Message_Instance::mutable_timeinfo() {
  set_has_timeinfo();
  if (timeinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    timeinfo_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.Instance.timeinfo)
  return timeinfo_;
}
inline ::std::string* Message_Instance::release_timeinfo() {
  clear_has_timeinfo();
  if (timeinfo_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = timeinfo_;
    timeinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_Instance::set_allocated_timeinfo(::std::string* timeinfo) {
  if (timeinfo_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete timeinfo_;
  }
  if (timeinfo) {
    set_has_timeinfo();
    timeinfo_ = timeinfo;
  } else {
    clear_has_timeinfo();
    timeinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Instance.timeinfo)
}

// optional int32 db_dayid = 19;
inline bool Message_Instance::has_db_dayid() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Message_Instance::set_has_db_dayid() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Message_Instance::clear_has_db_dayid() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Message_Instance::clear_db_dayid() {
  db_dayid_ = 0;
  clear_has_db_dayid();
}
inline ::google::protobuf::int32 Message_Instance::db_dayid() const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.db_dayid)
  return db_dayid_;
}
inline void Message_Instance::set_db_dayid(::google::protobuf::int32 value) {
  set_has_db_dayid();
  db_dayid_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.Instance.db_dayid)
}

// optional int32 db_recognition_setup_id = 20;
inline bool Message_Instance::has_db_recognition_setup_id() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Message_Instance::set_has_db_recognition_setup_id() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Message_Instance::clear_has_db_recognition_setup_id() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Message_Instance::clear_db_recognition_setup_id() {
  db_recognition_setup_id_ = 0;
  clear_has_db_recognition_setup_id();
}
inline ::google::protobuf::int32 Message_Instance::db_recognition_setup_id() const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.db_recognition_setup_id)
  return db_recognition_setup_id_;
}
inline void Message_Instance::set_db_recognition_setup_id(::google::protobuf::int32 value) {
  set_has_db_recognition_setup_id();
  db_recognition_setup_id_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.Instance.db_recognition_setup_id)
}

// optional string recname = 21;
inline bool Message_Instance::has_recname() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Message_Instance::set_has_recname() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Message_Instance::clear_has_recname() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Message_Instance::clear_recname() {
  if (recname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recname_->clear();
  }
  clear_has_recname();
}
inline const ::std::string& Message_Instance::recname() const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.recname)
  return *recname_;
}
inline void Message_Instance::set_recname(const ::std::string& value) {
  set_has_recname();
  if (recname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recname_ = new ::std::string;
  }
  recname_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.Instance.recname)
}
inline void Message_Instance::set_recname(const char* value) {
  set_has_recname();
  if (recname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recname_ = new ::std::string;
  }
  recname_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.Instance.recname)
}
inline void Message_Instance::set_recname(const char* value, size_t size) {
  set_has_recname();
  if (recname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recname_ = new ::std::string;
  }
  recname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.Instance.recname)
}
inline ::std::string* Message_Instance::mutable_recname() {
  set_has_recname();
  if (recname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.Instance.recname)
  return recname_;
}
inline ::std::string* Message_Instance::release_recname() {
  clear_has_recname();
  if (recname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = recname_;
    recname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_Instance::set_allocated_recname(::std::string* recname) {
  if (recname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete recname_;
  }
  if (recname) {
    set_has_recname();
    recname_ = recname;
  } else {
    clear_has_recname();
    recname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Instance.recname)
}

// optional string camera = 22;
inline bool Message_Instance::has_camera() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Message_Instance::set_has_camera() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Message_Instance::clear_has_camera() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Message_Instance::clear_camera() {
  if (camera_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camera_->clear();
  }
  clear_has_camera();
}
inline const ::std::string& Message_Instance::camera() const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.camera)
  return *camera_;
}
inline void Message_Instance::set_camera(const ::std::string& value) {
  set_has_camera();
  if (camera_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camera_ = new ::std::string;
  }
  camera_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.Instance.camera)
}
inline void Message_Instance::set_camera(const char* value) {
  set_has_camera();
  if (camera_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camera_ = new ::std::string;
  }
  camera_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.Instance.camera)
}
inline void Message_Instance::set_camera(const char* value, size_t size) {
  set_has_camera();
  if (camera_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camera_ = new ::std::string;
  }
  camera_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.Instance.camera)
}
inline ::std::string* Message_Instance::mutable_camera() {
  set_has_camera();
  if (camera_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camera_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.Instance.camera)
  return camera_;
}
inline ::std::string* Message_Instance::release_camera() {
  clear_has_camera();
  if (camera_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = camera_;
    camera_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_Instance::set_allocated_camera(::std::string* camera) {
  if (camera_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete camera_;
  }
  if (camera) {
    set_has_camera();
    camera_ = camera;
  } else {
    clear_has_camera();
    camera_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Instance.camera)
}

// optional int32 cameranumber = 23;
inline bool Message_Instance::has_cameranumber() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Message_Instance::set_has_cameranumber() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Message_Instance::clear_has_cameranumber() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Message_Instance::clear_cameranumber() {
  cameranumber_ = 0;
  clear_has_cameranumber();
}
inline ::google::protobuf::int32 Message_Instance::cameranumber() const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.cameranumber)
  return cameranumber_;
}
inline void Message_Instance::set_cameranumber(::google::protobuf::int32 value) {
  set_has_cameranumber();
  cameranumber_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.Instance.cameranumber)
}

// -------------------------------------------------------------------

// Message_Image

// optional string path = 1;
inline bool Message_Image::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message_Image::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message_Image::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message_Image::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& Message_Image::path() const {
  // @@protoc_insertion_point(field_get:motion.Message.Image.path)
  return *path_;
}
inline void Message_Image::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.Image.path)
}
inline void Message_Image::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.Image.path)
}
inline void Message_Image::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.Image.path)
}
inline ::std::string* Message_Image::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.Image.path)
  return path_;
}
inline ::std::string* Message_Image::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_Image::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Image.path)
}

// optional string name = 2;
inline bool Message_Image::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message_Image::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message_Image::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message_Image::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Message_Image::name() const {
  // @@protoc_insertion_point(field_get:motion.Message.Image.name)
  return *name_;
}
inline void Message_Image::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.Image.name)
}
inline void Message_Image::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.Image.name)
}
inline void Message_Image::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.Image.name)
}
inline ::std::string* Message_Image::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.Image.name)
  return name_;
}
inline ::std::string* Message_Image::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_Image::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Image.name)
}

// optional int32 imagechanges = 3;
inline bool Message_Image::has_imagechanges() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message_Image::set_has_imagechanges() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message_Image::clear_has_imagechanges() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message_Image::clear_imagechanges() {
  imagechanges_ = 0;
  clear_has_imagechanges();
}
inline ::google::protobuf::int32 Message_Image::imagechanges() const {
  // @@protoc_insertion_point(field_get:motion.Message.Image.imagechanges)
  return imagechanges_;
}
inline void Message_Image::set_imagechanges(::google::protobuf::int32 value) {
  set_has_imagechanges();
  imagechanges_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.Image.imagechanges)
}

// optional string time = 4;
inline bool Message_Image::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message_Image::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message_Image::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message_Image::clear_time() {
  if (time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& Message_Image::time() const {
  // @@protoc_insertion_point(field_get:motion.Message.Image.time)
  return *time_;
}
inline void Message_Image::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_ = new ::std::string;
  }
  time_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.Image.time)
}
inline void Message_Image::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_ = new ::std::string;
  }
  time_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.Image.time)
}
inline void Message_Image::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.Image.time)
}
inline ::std::string* Message_Image::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.Image.time)
  return time_;
}
inline ::std::string* Message_Image::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_Image::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Image.time)
}

// -------------------------------------------------------------------

// Message_Crop

// optional string rect = 1;
inline bool Message_Crop::has_rect() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message_Crop::set_has_rect() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message_Crop::clear_has_rect() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message_Crop::clear_rect() {
  if (rect_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rect_->clear();
  }
  clear_has_rect();
}
inline const ::std::string& Message_Crop::rect() const {
  // @@protoc_insertion_point(field_get:motion.Message.Crop.rect)
  return *rect_;
}
inline void Message_Crop::set_rect(const ::std::string& value) {
  set_has_rect();
  if (rect_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rect_ = new ::std::string;
  }
  rect_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.Crop.rect)
}
inline void Message_Crop::set_rect(const char* value) {
  set_has_rect();
  if (rect_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rect_ = new ::std::string;
  }
  rect_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.Crop.rect)
}
inline void Message_Crop::set_rect(const char* value, size_t size) {
  set_has_rect();
  if (rect_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rect_ = new ::std::string;
  }
  rect_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.Crop.rect)
}
inline ::std::string* Message_Crop::mutable_rect() {
  set_has_rect();
  if (rect_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rect_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.Crop.rect)
  return rect_;
}
inline ::std::string* Message_Crop::release_rect() {
  clear_has_rect();
  if (rect_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rect_;
    rect_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_Crop::set_allocated_rect(::std::string* rect) {
  if (rect_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rect_;
  }
  if (rect) {
    set_has_rect();
    rect_ = rect;
  } else {
    clear_has_rect();
    rect_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Crop.rect)
}

// optional int32 db_imagefatherid = 2;
inline bool Message_Crop::has_db_imagefatherid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message_Crop::set_has_db_imagefatherid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message_Crop::clear_has_db_imagefatherid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message_Crop::clear_db_imagefatherid() {
  db_imagefatherid_ = 0;
  clear_has_db_imagefatherid();
}
inline ::google::protobuf::int32 Message_Crop::db_imagefatherid() const {
  // @@protoc_insertion_point(field_get:motion.Message.Crop.db_imagefatherid)
  return db_imagefatherid_;
}
inline void Message_Crop::set_db_imagefatherid(::google::protobuf::int32 value) {
  set_has_db_imagefatherid();
  db_imagefatherid_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.Crop.db_imagefatherid)
}

// -------------------------------------------------------------------

// Message_Video

// optional string path = 1;
inline bool Message_Video::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message_Video::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message_Video::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message_Video::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& Message_Video::path() const {
  // @@protoc_insertion_point(field_get:motion.Message.Video.path)
  return *path_;
}
inline void Message_Video::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.Video.path)
}
inline void Message_Video::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.Video.path)
}
inline void Message_Video::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.Video.path)
}
inline ::std::string* Message_Video::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.Video.path)
  return path_;
}
inline ::std::string* Message_Video::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_Video::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Video.path)
}

// optional string name = 2;
inline bool Message_Video::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message_Video::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message_Video::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message_Video::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Message_Video::name() const {
  // @@protoc_insertion_point(field_get:motion.Message.Video.name)
  return *name_;
}
inline void Message_Video::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.Video.name)
}
inline void Message_Video::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.Video.name)
}
inline void Message_Video::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.Video.name)
}
inline ::std::string* Message_Video::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.Video.name)
  return name_;
}
inline ::std::string* Message_Video::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_Video::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Video.name)
}

// optional string instancefolder = 3;
inline bool Message_Video::has_instancefolder() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message_Video::set_has_instancefolder() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message_Video::clear_has_instancefolder() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message_Video::clear_instancefolder() {
  if (instancefolder_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instancefolder_->clear();
  }
  clear_has_instancefolder();
}
inline const ::std::string& Message_Video::instancefolder() const {
  // @@protoc_insertion_point(field_get:motion.Message.Video.instancefolder)
  return *instancefolder_;
}
inline void Message_Video::set_instancefolder(const ::std::string& value) {
  set_has_instancefolder();
  if (instancefolder_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instancefolder_ = new ::std::string;
  }
  instancefolder_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.Video.instancefolder)
}
inline void Message_Video::set_instancefolder(const char* value) {
  set_has_instancefolder();
  if (instancefolder_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instancefolder_ = new ::std::string;
  }
  instancefolder_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.Video.instancefolder)
}
inline void Message_Video::set_instancefolder(const char* value, size_t size) {
  set_has_instancefolder();
  if (instancefolder_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instancefolder_ = new ::std::string;
  }
  instancefolder_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.Video.instancefolder)
}
inline ::std::string* Message_Video::mutable_instancefolder() {
  set_has_instancefolder();
  if (instancefolder_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instancefolder_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.Video.instancefolder)
  return instancefolder_;
}
inline ::std::string* Message_Video::release_instancefolder() {
  clear_has_instancefolder();
  if (instancefolder_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = instancefolder_;
    instancefolder_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_Video::set_allocated_instancefolder(::std::string* instancefolder) {
  if (instancefolder_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete instancefolder_;
  }
  if (instancefolder) {
    set_has_instancefolder();
    instancefolder_ = instancefolder;
  } else {
    clear_has_instancefolder();
    instancefolder_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Video.instancefolder)
}

// -------------------------------------------------------------------

// Message

// optional int32 activecam = 1;
inline bool Message::has_activecam() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_activecam() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_activecam() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_activecam() {
  activecam_ = 0;
  clear_has_activecam();
}
inline ::google::protobuf::int32 Message::activecam() const {
  // @@protoc_insertion_point(field_get:motion.Message.activecam)
  return activecam_;
}
inline void Message::set_activecam(::google::protobuf::int32 value) {
  set_has_activecam();
  activecam_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.activecam)
}

// required .motion.Message.ActionType type = 2 [default = ENGAGE];
inline bool Message::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_type() {
  type_ = 1000;
  clear_has_type();
}
inline ::motion::Message_ActionType Message::type() const {
  // @@protoc_insertion_point(field_get:motion.Message.type)
  return static_cast< ::motion::Message_ActionType >(type_);
}
inline void Message::set_type(::motion::Message_ActionType value) {
  assert(::motion::Message_ActionType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.type)
}

// repeated .motion.Message.MotionUser motionuser = 3;
inline int Message::motionuser_size() const {
  return motionuser_.size();
}
inline void Message::clear_motionuser() {
  motionuser_.Clear();
}
inline const ::motion::Message_MotionUser& Message::motionuser(int index) const {
  // @@protoc_insertion_point(field_get:motion.Message.motionuser)
  return motionuser_.Get(index);
}
inline ::motion::Message_MotionUser* Message::mutable_motionuser(int index) {
  // @@protoc_insertion_point(field_mutable:motion.Message.motionuser)
  return motionuser_.Mutable(index);
}
inline ::motion::Message_MotionUser* Message::add_motionuser() {
  // @@protoc_insertion_point(field_add:motion.Message.motionuser)
  return motionuser_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionUser >&
Message::motionuser() const {
  // @@protoc_insertion_point(field_list:motion.Message.motionuser)
  return motionuser_;
}
inline ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionUser >*
Message::mutable_motionuser() {
  // @@protoc_insertion_point(field_mutable_list:motion.Message.motionuser)
  return &motionuser_;
}

// repeated .motion.Message.MotionCamera motioncamera = 4;
inline int Message::motioncamera_size() const {
  return motioncamera_.size();
}
inline void Message::clear_motioncamera() {
  motioncamera_.Clear();
}
inline const ::motion::Message_MotionCamera& Message::motioncamera(int index) const {
  // @@protoc_insertion_point(field_get:motion.Message.motioncamera)
  return motioncamera_.Get(index);
}
inline ::motion::Message_MotionCamera* Message::mutable_motioncamera(int index) {
  // @@protoc_insertion_point(field_mutable:motion.Message.motioncamera)
  return motioncamera_.Mutable(index);
}
inline ::motion::Message_MotionCamera* Message::add_motioncamera() {
  // @@protoc_insertion_point(field_add:motion.Message.motioncamera)
  return motioncamera_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionCamera >&
Message::motioncamera() const {
  // @@protoc_insertion_point(field_list:motion.Message.motioncamera)
  return motioncamera_;
}
inline ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionCamera >*
Message::mutable_motioncamera() {
  // @@protoc_insertion_point(field_mutable_list:motion.Message.motioncamera)
  return &motioncamera_;
}

// repeated .motion.Message.MotionDevice motiondevice = 5;
inline int Message::motiondevice_size() const {
  return motiondevice_.size();
}
inline void Message::clear_motiondevice() {
  motiondevice_.Clear();
}
inline const ::motion::Message_MotionDevice& Message::motiondevice(int index) const {
  // @@protoc_insertion_point(field_get:motion.Message.motiondevice)
  return motiondevice_.Get(index);
}
inline ::motion::Message_MotionDevice* Message::mutable_motiondevice(int index) {
  // @@protoc_insertion_point(field_mutable:motion.Message.motiondevice)
  return motiondevice_.Mutable(index);
}
inline ::motion::Message_MotionDevice* Message::add_motiondevice() {
  // @@protoc_insertion_point(field_add:motion.Message.motiondevice)
  return motiondevice_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionDevice >&
Message::motiondevice() const {
  // @@protoc_insertion_point(field_list:motion.Message.motiondevice)
  return motiondevice_;
}
inline ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionDevice >*
Message::mutable_motiondevice() {
  // @@protoc_insertion_point(field_mutable_list:motion.Message.motiondevice)
  return &motiondevice_;
}

// optional string time = 6;
inline bool Message::has_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Message::set_has_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Message::clear_has_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Message::clear_time() {
  if (time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& Message::time() const {
  // @@protoc_insertion_point(field_get:motion.Message.time)
  return *time_;
}
inline void Message::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_ = new ::std::string;
  }
  time_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.time)
}
inline void Message::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_ = new ::std::string;
  }
  time_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.time)
}
inline void Message::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.time)
}
inline ::std::string* Message::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.time)
  return time_;
}
inline ::std::string* Message::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.time)
}

// optional bytes data = 7;
inline bool Message::has_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Message::set_has_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Message::clear_has_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Message::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& Message::data() const {
  // @@protoc_insertion_point(field_get:motion.Message.data)
  return *data_;
}
inline void Message::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.data)
}
inline void Message::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.data)
}
inline void Message::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.data)
}
inline ::std::string* Message::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.data)
  return data_;
}
inline ::std::string* Message::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.data)
}

// optional int32 data_amount = 8;
inline bool Message::has_data_amount() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Message::set_has_data_amount() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Message::clear_has_data_amount() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Message::clear_data_amount() {
  data_amount_ = 0;
  clear_has_data_amount();
}
inline ::google::protobuf::int32 Message::data_amount() const {
  // @@protoc_insertion_point(field_get:motion.Message.data_amount)
  return data_amount_;
}
inline void Message::set_data_amount(::google::protobuf::int32 value) {
  set_has_data_amount();
  data_amount_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.data_amount)
}

// optional int32 data_total = 9;
inline bool Message::has_data_total() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Message::set_has_data_total() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Message::clear_has_data_total() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Message::clear_data_total() {
  data_total_ = 0;
  clear_has_data_total();
}
inline ::google::protobuf::int32 Message::data_total() const {
  // @@protoc_insertion_point(field_get:motion.Message.data_total)
  return data_total_;
}
inline void Message::set_data_total(::google::protobuf::int32 value) {
  set_has_data_total();
  data_total_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.data_total)
}

// optional string serverip = 10;
inline bool Message::has_serverip() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Message::set_has_serverip() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Message::clear_has_serverip() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Message::clear_serverip() {
  if (serverip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverip_->clear();
  }
  clear_has_serverip();
}
inline const ::std::string& Message::serverip() const {
  // @@protoc_insertion_point(field_get:motion.Message.serverip)
  return *serverip_;
}
inline void Message::set_serverip(const ::std::string& value) {
  set_has_serverip();
  if (serverip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverip_ = new ::std::string;
  }
  serverip_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.serverip)
}
inline void Message::set_serverip(const char* value) {
  set_has_serverip();
  if (serverip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverip_ = new ::std::string;
  }
  serverip_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.serverip)
}
inline void Message::set_serverip(const char* value, size_t size) {
  set_has_serverip();
  if (serverip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverip_ = new ::std::string;
  }
  serverip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.serverip)
}
inline ::std::string* Message::mutable_serverip() {
  set_has_serverip();
  if (serverip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.serverip)
  return serverip_;
}
inline ::std::string* Message::release_serverip() {
  clear_has_serverip();
  if (serverip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = serverip_;
    serverip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_serverip(::std::string* serverip) {
  if (serverip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete serverip_;
  }
  if (serverip) {
    set_has_serverip();
    serverip_ = serverip;
  } else {
    clear_has_serverip();
    serverip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.serverip)
}

// optional string clientip = 11;
inline bool Message::has_clientip() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Message::set_has_clientip() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Message::clear_has_clientip() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Message::clear_clientip() {
  if (clientip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientip_->clear();
  }
  clear_has_clientip();
}
inline const ::std::string& Message::clientip() const {
  // @@protoc_insertion_point(field_get:motion.Message.clientip)
  return *clientip_;
}
inline void Message::set_clientip(const ::std::string& value) {
  set_has_clientip();
  if (clientip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientip_ = new ::std::string;
  }
  clientip_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.clientip)
}
inline void Message::set_clientip(const char* value) {
  set_has_clientip();
  if (clientip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientip_ = new ::std::string;
  }
  clientip_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.clientip)
}
inline void Message::set_clientip(const char* value, size_t size) {
  set_has_clientip();
  if (clientip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientip_ = new ::std::string;
  }
  clientip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.clientip)
}
inline ::std::string* Message::mutable_clientip() {
  set_has_clientip();
  if (clientip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.clientip)
  return clientip_;
}
inline ::std::string* Message::release_clientip() {
  clear_has_clientip();
  if (clientip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = clientip_;
    clientip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_clientip(::std::string* clientip) {
  if (clientip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete clientip_;
  }
  if (clientip) {
    set_has_clientip();
    clientip_ = clientip;
  } else {
    clear_has_clientip();
    clientip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.clientip)
}

// optional string devicestarttime = 12;
inline bool Message::has_devicestarttime() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Message::set_has_devicestarttime() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Message::clear_has_devicestarttime() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Message::clear_devicestarttime() {
  if (devicestarttime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    devicestarttime_->clear();
  }
  clear_has_devicestarttime();
}
inline const ::std::string& Message::devicestarttime() const {
  // @@protoc_insertion_point(field_get:motion.Message.devicestarttime)
  return *devicestarttime_;
}
inline void Message::set_devicestarttime(const ::std::string& value) {
  set_has_devicestarttime();
  if (devicestarttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    devicestarttime_ = new ::std::string;
  }
  devicestarttime_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.devicestarttime)
}
inline void Message::set_devicestarttime(const char* value) {
  set_has_devicestarttime();
  if (devicestarttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    devicestarttime_ = new ::std::string;
  }
  devicestarttime_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.devicestarttime)
}
inline void Message::set_devicestarttime(const char* value, size_t size) {
  set_has_devicestarttime();
  if (devicestarttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    devicestarttime_ = new ::std::string;
  }
  devicestarttime_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.devicestarttime)
}
inline ::std::string* Message::mutable_devicestarttime() {
  set_has_devicestarttime();
  if (devicestarttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    devicestarttime_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.devicestarttime)
  return devicestarttime_;
}
inline ::std::string* Message::release_devicestarttime() {
  clear_has_devicestarttime();
  if (devicestarttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = devicestarttime_;
    devicestarttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_devicestarttime(::std::string* devicestarttime) {
  if (devicestarttime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete devicestarttime_;
  }
  if (devicestarttime) {
    set_has_devicestarttime();
    devicestarttime_ = devicestarttime;
  } else {
    clear_has_devicestarttime();
    devicestarttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.devicestarttime)
}

// optional string currmonth = 13;
inline bool Message::has_currmonth() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Message::set_has_currmonth() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Message::clear_has_currmonth() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Message::clear_currmonth() {
  if (currmonth_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currmonth_->clear();
  }
  clear_has_currmonth();
}
inline const ::std::string& Message::currmonth() const {
  // @@protoc_insertion_point(field_get:motion.Message.currmonth)
  return *currmonth_;
}
inline void Message::set_currmonth(const ::std::string& value) {
  set_has_currmonth();
  if (currmonth_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currmonth_ = new ::std::string;
  }
  currmonth_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.currmonth)
}
inline void Message::set_currmonth(const char* value) {
  set_has_currmonth();
  if (currmonth_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currmonth_ = new ::std::string;
  }
  currmonth_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.currmonth)
}
inline void Message::set_currmonth(const char* value, size_t size) {
  set_has_currmonth();
  if (currmonth_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currmonth_ = new ::std::string;
  }
  currmonth_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.currmonth)
}
inline ::std::string* Message::mutable_currmonth() {
  set_has_currmonth();
  if (currmonth_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currmonth_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.currmonth)
  return currmonth_;
}
inline ::std::string* Message::release_currmonth() {
  clear_has_currmonth();
  if (currmonth_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = currmonth_;
    currmonth_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_currmonth(::std::string* currmonth) {
  if (currmonth_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete currmonth_;
  }
  if (currmonth) {
    set_has_currmonth();
    currmonth_ = currmonth;
  } else {
    clear_has_currmonth();
    currmonth_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.currmonth)
}

// optional string currday = 14;
inline bool Message::has_currday() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Message::set_has_currday() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Message::clear_has_currday() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Message::clear_currday() {
  if (currday_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currday_->clear();
  }
  clear_has_currday();
}
inline const ::std::string& Message::currday() const {
  // @@protoc_insertion_point(field_get:motion.Message.currday)
  return *currday_;
}
inline void Message::set_currday(const ::std::string& value) {
  set_has_currday();
  if (currday_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currday_ = new ::std::string;
  }
  currday_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.currday)
}
inline void Message::set_currday(const char* value) {
  set_has_currday();
  if (currday_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currday_ = new ::std::string;
  }
  currday_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.currday)
}
inline void Message::set_currday(const char* value, size_t size) {
  set_has_currday();
  if (currday_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currday_ = new ::std::string;
  }
  currday_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.currday)
}
inline ::std::string* Message::mutable_currday() {
  set_has_currday();
  if (currday_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currday_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.currday)
  return currday_;
}
inline ::std::string* Message::release_currday() {
  clear_has_currday();
  if (currday_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = currday_;
    currday_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_currday(::std::string* currday) {
  if (currday_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete currday_;
  }
  if (currday) {
    set_has_currday();
    currday_ = currday;
  } else {
    clear_has_currday();
    currday_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.currday)
}

// optional string currdaytitle = 15;
inline bool Message::has_currdaytitle() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Message::set_has_currdaytitle() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Message::clear_has_currdaytitle() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Message::clear_currdaytitle() {
  if (currdaytitle_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currdaytitle_->clear();
  }
  clear_has_currdaytitle();
}
inline const ::std::string& Message::currdaytitle() const {
  // @@protoc_insertion_point(field_get:motion.Message.currdaytitle)
  return *currdaytitle_;
}
inline void Message::set_currdaytitle(const ::std::string& value) {
  set_has_currdaytitle();
  if (currdaytitle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currdaytitle_ = new ::std::string;
  }
  currdaytitle_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.currdaytitle)
}
inline void Message::set_currdaytitle(const char* value) {
  set_has_currdaytitle();
  if (currdaytitle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currdaytitle_ = new ::std::string;
  }
  currdaytitle_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.currdaytitle)
}
inline void Message::set_currdaytitle(const char* value, size_t size) {
  set_has_currdaytitle();
  if (currdaytitle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currdaytitle_ = new ::std::string;
  }
  currdaytitle_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.currdaytitle)
}
inline ::std::string* Message::mutable_currdaytitle() {
  set_has_currdaytitle();
  if (currdaytitle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currdaytitle_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.currdaytitle)
  return currdaytitle_;
}
inline ::std::string* Message::release_currdaytitle() {
  clear_has_currdaytitle();
  if (currdaytitle_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = currdaytitle_;
    currdaytitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_currdaytitle(::std::string* currdaytitle) {
  if (currdaytitle_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete currdaytitle_;
  }
  if (currdaytitle) {
    set_has_currdaytitle();
    currdaytitle_ = currdaytitle;
  } else {
    clear_has_currdaytitle();
    currdaytitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.currdaytitle)
}

// optional int32 currcam = 16;
inline bool Message::has_currcam() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Message::set_has_currcam() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Message::clear_has_currcam() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Message::clear_currcam() {
  currcam_ = 0;
  clear_has_currcam();
}
inline ::google::protobuf::int32 Message::currcam() const {
  // @@protoc_insertion_point(field_get:motion.Message.currcam)
  return currcam_;
}
inline void Message::set_currcam(::google::protobuf::int32 value) {
  set_has_currcam();
  currcam_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.currcam)
}

// optional int32 packagesize = 17;
inline bool Message::has_packagesize() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Message::set_has_packagesize() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Message::clear_has_packagesize() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Message::clear_packagesize() {
  packagesize_ = 0;
  clear_has_packagesize();
}
inline ::google::protobuf::int32 Message::packagesize() const {
  // @@protoc_insertion_point(field_get:motion.Message.packagesize)
  return packagesize_;
}
inline void Message::set_packagesize(::google::protobuf::int32 value) {
  set_has_packagesize();
  packagesize_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.packagesize)
}

// optional string imagefilepath = 18;
inline bool Message::has_imagefilepath() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Message::set_has_imagefilepath() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Message::clear_has_imagefilepath() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Message::clear_imagefilepath() {
  if (imagefilepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imagefilepath_->clear();
  }
  clear_has_imagefilepath();
}
inline const ::std::string& Message::imagefilepath() const {
  // @@protoc_insertion_point(field_get:motion.Message.imagefilepath)
  return *imagefilepath_;
}
inline void Message::set_imagefilepath(const ::std::string& value) {
  set_has_imagefilepath();
  if (imagefilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imagefilepath_ = new ::std::string;
  }
  imagefilepath_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.imagefilepath)
}
inline void Message::set_imagefilepath(const char* value) {
  set_has_imagefilepath();
  if (imagefilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imagefilepath_ = new ::std::string;
  }
  imagefilepath_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.imagefilepath)
}
inline void Message::set_imagefilepath(const char* value, size_t size) {
  set_has_imagefilepath();
  if (imagefilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imagefilepath_ = new ::std::string;
  }
  imagefilepath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.imagefilepath)
}
inline ::std::string* Message::mutable_imagefilepath() {
  set_has_imagefilepath();
  if (imagefilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imagefilepath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.imagefilepath)
  return imagefilepath_;
}
inline ::std::string* Message::release_imagefilepath() {
  clear_has_imagefilepath();
  if (imagefilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = imagefilepath_;
    imagefilepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_imagefilepath(::std::string* imagefilepath) {
  if (imagefilepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete imagefilepath_;
  }
  if (imagefilepath) {
    set_has_imagefilepath();
    imagefilepath_ = imagefilepath;
  } else {
    clear_has_imagefilepath();
    imagefilepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.imagefilepath)
}

// optional string videofilepath = 19;
inline bool Message::has_videofilepath() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Message::set_has_videofilepath() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Message::clear_has_videofilepath() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Message::clear_videofilepath() {
  if (videofilepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    videofilepath_->clear();
  }
  clear_has_videofilepath();
}
inline const ::std::string& Message::videofilepath() const {
  // @@protoc_insertion_point(field_get:motion.Message.videofilepath)
  return *videofilepath_;
}
inline void Message::set_videofilepath(const ::std::string& value) {
  set_has_videofilepath();
  if (videofilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    videofilepath_ = new ::std::string;
  }
  videofilepath_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.videofilepath)
}
inline void Message::set_videofilepath(const char* value) {
  set_has_videofilepath();
  if (videofilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    videofilepath_ = new ::std::string;
  }
  videofilepath_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.videofilepath)
}
inline void Message::set_videofilepath(const char* value, size_t size) {
  set_has_videofilepath();
  if (videofilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    videofilepath_ = new ::std::string;
  }
  videofilepath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.videofilepath)
}
inline ::std::string* Message::mutable_videofilepath() {
  set_has_videofilepath();
  if (videofilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    videofilepath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.videofilepath)
  return videofilepath_;
}
inline ::std::string* Message::release_videofilepath() {
  clear_has_videofilepath();
  if (videofilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = videofilepath_;
    videofilepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_videofilepath(::std::string* videofilepath) {
  if (videofilepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete videofilepath_;
  }
  if (videofilepath) {
    set_has_videofilepath();
    videofilepath_ = videofilepath;
  } else {
    clear_has_videofilepath();
    videofilepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.videofilepath)
}

// optional string recname = 20;
inline bool Message::has_recname() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Message::set_has_recname() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Message::clear_has_recname() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Message::clear_recname() {
  if (recname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recname_->clear();
  }
  clear_has_recname();
}
inline const ::std::string& Message::recname() const {
  // @@protoc_insertion_point(field_get:motion.Message.recname)
  return *recname_;
}
inline void Message::set_recname(const ::std::string& value) {
  set_has_recname();
  if (recname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recname_ = new ::std::string;
  }
  recname_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.recname)
}
inline void Message::set_recname(const char* value) {
  set_has_recname();
  if (recname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recname_ = new ::std::string;
  }
  recname_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.recname)
}
inline void Message::set_recname(const char* value, size_t size) {
  set_has_recname();
  if (recname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recname_ = new ::std::string;
  }
  recname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.recname)
}
inline ::std::string* Message::mutable_recname() {
  set_has_recname();
  if (recname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    recname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.recname)
  return recname_;
}
inline ::std::string* Message::release_recname() {
  clear_has_recname();
  if (recname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = recname_;
    recname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_recname(::std::string* recname) {
  if (recname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete recname_;
  }
  if (recname) {
    set_has_recname();
    recname_ = recname;
  } else {
    clear_has_recname();
    recname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.recname)
}

// optional int32 activecamnum = 21;
inline bool Message::has_activecamnum() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Message::set_has_activecamnum() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Message::clear_has_activecamnum() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Message::clear_activecamnum() {
  activecamnum_ = 0;
  clear_has_activecamnum();
}
inline ::google::protobuf::int32 Message::activecamnum() const {
  // @@protoc_insertion_point(field_get:motion.Message.activecamnum)
  return activecamnum_;
}
inline void Message::set_activecamnum(::google::protobuf::int32 value) {
  set_has_activecamnum();
  activecamnum_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.activecamnum)
}

// optional bool includethubmnails = 22;
inline bool Message::has_includethubmnails() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Message::set_has_includethubmnails() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Message::clear_has_includethubmnails() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Message::clear_includethubmnails() {
  includethubmnails_ = false;
  clear_has_includethubmnails();
}
inline bool Message::includethubmnails() const {
  // @@protoc_insertion_point(field_get:motion.Message.includethubmnails)
  return includethubmnails_;
}
inline void Message::set_includethubmnails(bool value) {
  set_has_includethubmnails();
  includethubmnails_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.includethubmnails)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace motion

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::motion::Message_ResponseType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::motion::Message_ResponseType>() {
  return ::motion::Message_ResponseType_descriptor();
}
template <> struct is_proto_enum< ::motion::Message_ActionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::motion::Message_ActionType>() {
  return ::motion::Message_ActionType_descriptor();
}
template <> struct is_proto_enum< ::motion::Message_SocketType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::motion::Message_SocketType>() {
  return ::motion::Message_SocketType_descriptor();
}
template <> struct is_proto_enum< ::motion::Message_ProcessType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::motion::Message_ProcessType>() {
  return ::motion::Message_ProcessType_descriptor();
}
template <> struct is_proto_enum< ::motion::Message_ServiceType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::motion::Message_ServiceType>() {
  return ::motion::Message_ServiceType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_motion_2eproto__INCLUDED
